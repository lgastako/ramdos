<!DOCTYPE html>

<html>
<head>
  <title>ramda.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="ramda.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>ramda.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <pre><code>ramda.js <span class="hljs-number">0.3</span><span class="hljs-number">.0</span>
https:<span class="hljs-comment">//github.com/CrossEye/ramda</span>
(c) <span class="hljs-number">2013</span>-<span class="hljs-number">2014</span> Scott Sauyet and Michael Hurley
Ramda may be freely distributed under the MIT license.
</code></pre>
            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="ramda">Ramda</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A practical functional library for Javascript programmers.  Ramda is a collection of tools to make it easier to
use Javascript as a functional programming language.  (The name is just a silly play on <code>lambda</code>.)</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="basic-setup">Basic Setup</h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Uses a technique from the <a href="https://github.com/umdjs/umd/blob/master/returnExports.js">Universal Module Definition</a> to wrap this up for use in Node.js or in the browser,
with or without an AMD-style loader.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, factory)</span> </span>{<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">'object'</span>) {<span class="hljs-built_in">module</span>.exports = factory(root);} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {define(factory);} <span class="hljs-keyword">else</span> {root.ramda = factory(root);}}(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(global)</span> </span>{
<span class="hljs-pi">
    "use strict"</span>;
    <span class="hljs-keyword">return</span>  (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>This object is what is actually returned, with all the exposed functions attached as properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        <span class="hljs-keyword">var</span> R = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2 id="internal-functions-and-properties">Internal Functions and Properties</h2>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * Creates an alias for a public function.
         *
         * @private
         * @category Internal
         * @param {string} oldName The name of the public function to alias.
         * @return {Function} A function decorated with the `is`, `are`, and `and` methods. Create
         * an alias for the `oldName function by invoking any of these methods an passing it a
         * string with the `newName` parameter.
         * @example
         *
         * // Create an alias for `each` named `forEach`
         * aliasFor('each').is('forEach');
         */</span>
        <span class="hljs-keyword">var</span> aliasFor = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(oldName)</span> </span>{
            <span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newName)</span> </span>{
                R[newName] = R[oldName];
                <span class="hljs-keyword">return</span> fn;
            };
            fn.is = fn.are = fn.and = fn;
            <span class="hljs-keyword">return</span> fn;
        };

        <span class="hljs-comment">/**
         * An optimized, private array `slice` implementation.
         *
         * @private
         * @category Internal
         * @param {Arguments|Array} args The array or arguments object to consider.
         * @param {number} [from=0] The array index to slice from, inclusive.
         * @param {number} [to=args.length] The array index to slice to, exclusive.
         * @return {Array} A new, sliced array.
         * @example
         *
         * _slice([1, 2, 3, 4, 5], 1, 3); //=&gt; [2, 3]
         *
         * var firstThreeArgs = function(a, b, c, d) {
         *   return _slice(arguments, 0, 3);
         * };
         * firstThreeArgs(1, 2, 3, 4); //=&gt; [1, 2, 3]
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_slice</span><span class="hljs-params">(args, from, to)</span> </span>{
            from = (<span class="hljs-keyword">typeof</span> from === <span class="hljs-string">"number"</span> ) ? from : <span class="hljs-number">0</span>;
            to = (<span class="hljs-keyword">typeof</span> to === <span class="hljs-string">"number"</span> ) ? to : args.length;
            <span class="hljs-keyword">var</span> length = to - from,
                arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(length),
                i = -<span class="hljs-number">1</span>;

            <span class="hljs-keyword">while</span> (++i &lt; length) {
                arr[i] = args[from + i];
            }
            <span class="hljs-keyword">return</span> arr;
        }

        <span class="hljs-comment">/**
         * Private `concat` function to merge two array-like objects.
         *
         * @private
         * @category Internal
         * @param {Array|Arguments} [set1=[]] An array-like object.
         * @param {Array|Arguments} [set2=[]] An array-like object.
         * @return {Array} A new, merged array.
         * @example
         *
         * concat([4, 5, 6], [1, 2, 3]); //=&gt; [4, 5, 6, 1, 2, 3]
         */</span>
        <span class="hljs-keyword">var</span> concat = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_concat</span><span class="hljs-params">(set1, set2)</span> </span>{
            set1 = set1 || [];
            set2 = set2 || [];
            <span class="hljs-keyword">var</span> length1 = set1.length,
                length2 = set2.length,
                result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(length1 + length2);

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length1; i++) {
                result[i] = set1[i];
            }
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length2; i++) {
                result[i + length1] = set2[i];
            }
            <span class="hljs-keyword">return</span> result;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Private reference to toString function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> toString = <span class="hljs-built_in">Object</span>.prototype.toString;

        <span class="hljs-comment">/**
         * Tests whether or not an object is an array.
         *
         * @private
         * @category Internal
         * @param {*} val The object to test.
         * @return {boolean} `true` if `val` is an array, `false` otherwise.
         * @example
         *
         * isArray([]); //=&gt; true
         * isArray(true); //=&gt; false
         * isArray({}); //=&gt; false
         */</span>
        <span class="hljs-keyword">var</span> isArray = <span class="hljs-built_in">Array</span>.isArray || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isArray</span><span class="hljs-params">(val)</span> </span>{
            <span class="hljs-keyword">return</span> val &amp;&amp; val.length &gt;= <span class="hljs-number">0</span> &amp;&amp; toString.call(val) === <span class="hljs-string">"[object Array]"</span>;
        };

        <span class="hljs-comment">/**
         * Tests whether or not an object is similar to an array.
         *
         * @private
         * @category Internal
         * @param {*} val The object to test.
         * @return {boolean} `true` if `val` has a numeric length property; `false` otherwise.
         * @example
         *
         * isArrayLike([]); //=&gt; true
         * isArrayLike(true); //=&gt; false
         * isArrayLike({}); //=&gt; false
         * isArrayLike({length: 10}); //=&gt; true
         */</span>
        <span class="hljs-keyword">var</span> isArrayLike = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> </span>{
            <span class="hljs-keyword">return</span> x != <span class="hljs-literal">null</span> &amp;&amp; x.length &gt;= <span class="hljs-number">0</span> &amp;&amp; (isArray(x) || !R.is(<span class="hljs-built_in">String</span>, x));
        };

        <span class="hljs-comment">/**
         * Creates a new version of `fn` that, when invoked, will return either:
         * - A new function ready to accept one or more of `fn`'s remaining arguments, if all of
         * `fn`'s expected arguments have not yet been provided
         * - `fn`'s result if all of its expected arguments have been provided
         *
         * Optionally, you may provide an arity for the returned function.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to curry.
         * @param {number} [fnArity=fn.length] An optional arity for the returned function.
         * @return {Function} A new, curried function.
         * @example
         *
         * var addFourNumbers = function(a, b, c, d) {
         *   return a + b + c + d;
         * };
         *
         * var curriedAddFourNumbers = curry(addFourNumbers);
         * var f = curriedAddFourNumbers(1, 2);
         * var g = f(3);
         * g(4);//=&gt; 10
         */</span>
        <span class="hljs-keyword">var</span> curry = R.curry = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_curry</span><span class="hljs-params">(fn, fnArity)</span> </span>{
            fnArity = <span class="hljs-keyword">typeof</span> fnArity === <span class="hljs-string">"number"</span> ? fnArity : fn.length;
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recurry</span><span class="hljs-params">(args)</span> </span>{
                <span class="hljs-keyword">return</span> arity(<span class="hljs-built_in">Math</span>.max(fnArity - (args &amp;&amp; args.length || <span class="hljs-number">0</span>), <span class="hljs-number">0</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">0</span>) { <span class="hljs-keyword">throw</span> NO_ARGS_EXCEPTION; }
                    <span class="hljs-keyword">var</span> newArgs = concat(args, <span class="hljs-built_in">arguments</span>);
                    <span class="hljs-keyword">if</span> (newArgs.length &gt;= fnArity) {
                        <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, newArgs);
                    }
                    <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span> recurry(newArgs);
                    }
                });
            }

            <span class="hljs-keyword">return</span> recurry([]);
        };

        <span class="hljs-keyword">var</span> NO_ARGS_EXCEPTION = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Function called with no arguments'</span>);

        <span class="hljs-comment">/**
         * Optimized internal two-arity curry function.
         *
         * @private
         * @category Function
         * @param {Function} fn The function to curry.
         * @return {Function} curried function
         * @example
         *
         * var addTwo = function(a, b) {
         *   return a + b;
         * };
         * var curriedAddTwo = curry2(addTwo);
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry2</span><span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
                <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
                    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">throw</span> NO_ARGS_EXCEPTION;
                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{
                        <span class="hljs-keyword">return</span> fn(a, b);
                    };
                }
                <span class="hljs-keyword">return</span> fn(a, b);
            };
        }

        <span class="hljs-comment">/**
         * Optimized internal three-arity curry function.
         *
         * @private
         * @category Function
         * @param {Function} fn The function to curry.
         * @return {Function} curried function
         * @example
         *
         * var addThree = function(a, b, c) {
         *   return a + b + c;
         * };
         * var curriedAddThree = curry3(addThree);
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry3</span><span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b, c)</span> </span>{
                <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
                    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">throw</span> NO_ARGS_EXCEPTION;
                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b, c)</span> </span>{
                        <span class="hljs-keyword">return</span> fn(a, b, c);
                    });
                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(c)</span> </span>{
                        <span class="hljs-keyword">return</span> fn(a, b, c);
                    };
                }
                <span class="hljs-keyword">return</span> fn(a, b, c);
            };
        }

        <span class="hljs-comment">/**
         * Private function that determines whether or not a provided object has a given method.
         * Does not ignore methods stored on the object's prototype chain. Used for dynamically
         * dispatching Ramda methods to non-Array objects.
         *
         * @private
         * @category Internal
         * @param {string} methodName The name of the method to check for.
         * @param {Object} obj The object to test.
         * @return {boolean} `true` has a given method, `false` otherwise.
         * @example
         *
         * var person = { name: 'John' };
         * person.shout = function() { alert(this.name); };
         *
         * hasMethod('shout', person); //=&gt; true
         * hasMethod('foo', person); //=&gt; false
         */</span>
        <span class="hljs-keyword">var</span> hasMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_hasMethod</span><span class="hljs-params">(methodName, obj)</span> </span>{
            <span class="hljs-keyword">return</span> obj &amp;&amp; !isArray(obj) &amp;&amp; <span class="hljs-keyword">typeof</span> obj[methodName] === <span class="hljs-string">'function'</span>;
        };

        <span class="hljs-comment">/**
         * Similar to hasMethod, this checks whether a function has a [methodname]
         * function. If it isn't an array it will execute that function otherwise it will
         * default to the ramda implementation.
         *
         * @private
         * @category Internal
         * @param {Function} func ramda implemtation
         * @param {String} methodname property to check for a custom implementation
         * @return {Object} whatever the return value of the method is
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkForMethod</span><span class="hljs-params">(methodname, func)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b, c)</span> </span>{
                <span class="hljs-keyword">var</span> length = <span class="hljs-built_in">arguments</span>.length;
                <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">arguments</span>[length - <span class="hljs-number">1</span>],
                    callBound = obj &amp;&amp; !isArray(obj) &amp;&amp; <span class="hljs-keyword">typeof</span> obj[methodname] === <span class="hljs-string">'function'</span>;
                <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
                    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> func();
                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> callBound ? obj[methodname]() : func(a);
                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> callBound ? obj[methodname](a) : func(a, b);
                    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> callBound ? obj[methodname](a, b) : func(a, b, c);
                    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> callBound ? obj[methodname](a, b, c) : func(a, b, c, obj);
                }
            };
        }

        <span class="hljs-comment">/**
         * Private function that generates a parameter list based on the paremeter count passed in.
         *
         * @private
         * @category Internal
         * @param {number} n The number of parameters
         * @return {string} The parameter list
         * @example
         *
         * mkArgStr(1); //= "arg1"
         * mkArgStr(2); //= "arg1, arg2"
         * mkArgStr(3); //= "arg1, arg2, arg3"
         */</span>
        <span class="hljs-keyword">var</span> mkArgStr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_makeArgStr</span><span class="hljs-params">(n)</span> </span>{
            <span class="hljs-keyword">var</span> arr = [], idx = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++idx &lt; n) {
                arr[idx] = <span class="hljs-string">"arg"</span> + idx;
            }
            <span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">", "</span>);
        };

        <span class="hljs-comment">/**
         * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`
         * parameters. Any extraneous parameters will not be passed to the supplied function.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {number} n The desired arity of the new function.
         * @param {Function} fn The function to wrap.
         * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
         * arity `n`.
         * @example
         *
         * var takesTwoArgs = function(a, b) {
         *   return [a, b];
         * };
         * takesTwoArgs.length; //=&gt; 2
         * takesTwoArgs(1, 2); //=&gt; [1, 2]
         *
         * var takesOneArg = ramda.nAry(1, takesTwoArgs);
         * takesOneArg.length; //=&gt; 1
         * // Only `n` arguments are passed to the wrapped function
         * takesOneArg(1, 2); //=&gt; [1, undefined]
         */</span>
        <span class="hljs-keyword">var</span> nAry = R.nAry = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> cache = {
                <span class="hljs-number">0</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                        <span class="hljs-keyword">return</span> func.call(<span class="hljs-keyword">this</span>);
                    };
                },
                <span class="hljs-number">1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0)</span> </span>{
                        <span class="hljs-keyword">return</span> func.call(<span class="hljs-keyword">this</span>, arg0);
                    };
                },
                <span class="hljs-number">2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0, arg1)</span> </span>{
                        <span class="hljs-keyword">return</span> func.call(<span class="hljs-keyword">this</span>, arg0, arg1);
                    };
                },
                <span class="hljs-number">3</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0, arg1, arg2)</span> </span>{
                        <span class="hljs-keyword">return</span> func.call(<span class="hljs-keyword">this</span>, arg0, arg1, arg2);
                    };
                }
            };</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <pre><code>For example:
cache[<span class="hljs-number">5</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg0, arg1, arg2, arg3, arg4)</span> </span>{
        <span class="hljs-keyword">return</span> func.call(<span class="hljs-keyword">this</span>, arg0, arg1, arg2, arg3, arg4);
    }
};
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">var</span> makeN = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> </span>{
                <span class="hljs-keyword">var</span> fnArgs = mkArgStr(n);
                <span class="hljs-keyword">var</span> body = [
                        <span class="hljs-string">"    return function("</span> + fnArgs + <span class="hljs-string">") {"</span>,
                        <span class="hljs-string">"        return func.call(this"</span> + (fnArgs ? <span class="hljs-string">", "</span> + fnArgs : <span class="hljs-string">""</span>) + <span class="hljs-string">");"</span>,
                    <span class="hljs-string">"    }"</span>
                ].join(<span class="hljs-string">"\n"</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">"func"</span>, body);
            };

            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_nAry</span><span class="hljs-params">(n, fn)</span> </span>{
                <span class="hljs-keyword">return</span> (cache[n] || (cache[n] = makeN(n)))(fn);
            };
        }());

        <span class="hljs-comment">/**
         * Wraps a function of any arity (including nullary) in a function that accepts exactly 1
         * parameter. Any extraneous parameters will not be passed to the supplied function.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to wrap.
         * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
         * arity 1.
         * @example
         *
         * var takesTwoArgs = function(a, b) {
         *   return [a, b];
         * };
         * takesTwoArgs.length; //=&gt; 2
         * takesTwoArgs(1, 2); //=&gt; [1, 2]
         *
         * var takesOneArg = ramda.unary(1, takesTwoArgs);
         * takesOneArg.length; //=&gt; 1
         * // Only 1 argument is passed to the wrapped function
         * takesOneArg(1, 2); //=&gt; [1, undefined]
         */</span>
        R.unary = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unary</span><span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> nAry(<span class="hljs-number">1</span>, fn);
        };

        <span class="hljs-comment">/**
         * Wraps a function of any arity (including nullary) in a function that accepts exactly 2
         * parameters. Any extraneous parameters will not be passed to the supplied function.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to wrap.
         * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
         * arity 2.
         * @example
         *
         * var takesThreeArgs = function(a, b, c) {
         *   return [a, b, c];
         * };
         * takesThreeArgs.length; //=&gt; 3
         * takesThreeArgs(1, 2, 3); //=&gt; [1, 2, 3]
         *
         * var takesTwoArgs = ramda.binary(1, takesThreeArgs);
         * takesTwoArgs.length; //=&gt; 2
         * // Only 2 arguments are passed to the wrapped function
         * takesTwoArgs(1, 2, 3); //=&gt; [1, 2, undefined]
         */</span>
        <span class="hljs-keyword">var</span> binary = R.binary = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_binary</span><span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> nAry(<span class="hljs-number">2</span>, fn);
        };

        <span class="hljs-comment">/**
         * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`
         * parameters. Unlike `nAry`, which passes only `n` arguments to the wrapped function,
         * functions produced by `arity` will pass all provided arguments to the wrapped function.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {number} n The desired arity of the returned function.
         * @param {Function} fn The function to wrap.
         * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
         * arity `n`.
         * @example
         *
         * var takesTwoArgs = function(a, b) {
         *   return [a, b];
         * };
         * takesTwoArgs.length; //=&gt; 2
         * takesTwoArgs(1, 2); //=&gt; [1, 2]
         *
         * var takesOneArg = ramda.unary(1, takesTwoArgs);
         * takesOneArg.length; //=&gt; 1
         * // All arguments are passed through to the wrapped function
         * takesOneArg(1, 2); //=&gt; [1, 2]
         */</span>
        <span class="hljs-keyword">var</span> arity = R.arity = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> cache = {
                <span class="hljs-number">0</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                        <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                    };
                },
                <span class="hljs-number">1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0)</span> </span>{
                        <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                    };
                },
                <span class="hljs-number">2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0, arg1)</span> </span>{
                        <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                    };
                },
                <span class="hljs-number">3</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0, arg1, arg2)</span> </span>{
                        <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                    };
                }
            };</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <pre><code>For example:
cache[<span class="hljs-number">5</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg0, arg1, arg2, arg3, arg4)</span> </span>{
        <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
};
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">var</span> makeN = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> </span>{
                <span class="hljs-keyword">var</span> fnArgs = mkArgStr(n);
                <span class="hljs-keyword">var</span> body = [
                        <span class="hljs-string">"    return function("</span> + fnArgs + <span class="hljs-string">") {"</span>,
                    <span class="hljs-string">"        return func.apply(this, arguments);"</span>,
                    <span class="hljs-string">"    }"</span>
                ].join(<span class="hljs-string">"\n"</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">"func"</span>, body);
            };

            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arity</span><span class="hljs-params">(n, fn)</span> </span>{
                <span class="hljs-keyword">return</span> (cache[n] || (cache[n] = makeN(n)))(fn);
            };
        }());

        <span class="hljs-comment">/**
         * Turns a named method of an object (or object prototype) into a function that can be
         * called directly. Passing the optional `len` parameter restricts the returned function to
         * the initial `len` parameters of the method.
         *
         * The returned function is curried and accepts `len + 1` parameters (or `method.length + 1`
         * when `len` is not specified), and the final parameter is the target object.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {string} name The name of the method to wrap.
         * @param {Object} obj The object to search for the `name` method.
         * @param [len] The desired arity of the wrapped method.
         * @return {Function} A new function or `undefined` if the specified method is not found.
         * @example
         *
         *
         * var charAt = ramda.invoker('charAt', String.prototype);
         * charAt(6, 'abcdefghijklm'); //=&gt; 'g'
         *
         * var join = ramda.invoker('join', Array.prototype);
         * var firstChar = charAt(0);
         * join('', ramda.map(firstChar, ["light", "ampliifed", "stimulated", "emission", "radiation"]));
         * //=&gt; 'laser'
         */</span>
        <span class="hljs-keyword">var</span> invoker = R.invoker = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_invoker</span><span class="hljs-params">(name, obj, len)</span> </span>{
            <span class="hljs-keyword">var</span> method = obj[name];
            <span class="hljs-keyword">var</span> length = len === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? method.length : len;
            <span class="hljs-keyword">return</span> method &amp;&amp; curry(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length) {
                    <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">Array</span>.prototype.pop.call(<span class="hljs-built_in">arguments</span>);
                    <span class="hljs-keyword">var</span> targetMethod = target[name];
                    <span class="hljs-keyword">if</span> (targetMethod == method) {
                        <span class="hljs-keyword">return</span> targetMethod.apply(target, <span class="hljs-built_in">arguments</span>);
                    }
                }
            }, length + <span class="hljs-number">1</span>);
        };

        <span class="hljs-comment">/**
         * Accepts a function `fn` and any number of transformer functions and returns a new
         * function. When the new function is invoked, it calls the function `fn` with parameters
         * consisting of the result of calling each supplied handler on successive arguments to the
         * new function. For example:
         *
         * ```javascript
         *   var useWithExample = invoke(someFn, transformerFn1, transformerFn2);
         *
         *   // This invocation:
         *   useWithExample('x', 'y');
         *   // Is functionally equivalent to:
         *   someFn(transformerFn1('x'), transformerFn2('y'))
         * ```
         *
         * If more arguments are passed to the returned function than transformer functions, those
         * arguments are passed directly to `fn` as additional parameters. If you expect additional
         * arguments that don't need to be transformed, although you can ignore them, it's best to
         * pass an identity function so that the new function reports the correct arity.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to wrap.
         * @param {...Function} transformers A variable number of transformer functions
         * @return {Function} The wrapped function.
         * @example
         *
         * var double = function(y) { return y * 2; };
         * var square = function(x) { return x * x; };
         * var add = function(a, b) { return a + b; };
         * // Adds any number of arguments together
         * var addAll = function() {
         *   return ramda.reduce(add, 0, arguments);
         * };
         *
         * // Basic example
         * var addDoubleAndSquare = ramda.useWith(addAll, double, square);
         *
         * addDoubleAndSquare(10, 5); //≅ addAll(double(10), square(5));
         * //=&gt; 125
         *
         * // Example of passing more arguments than transformers
         * addDoubleAndSquare(10, 5, 100); //≅ addAll(double(10), square(5), 100);
         * //=&gt; 225
         *
         * // But if you're expecting additional arguments that don't need transformation, it's best
         * // to pass transformer functions so the resulting function has the correct arity
         * var addDoubleAndSquareWithExtraParams = ramda.useWith(addAll, double, square, ramda.identity);
         * addDoubleAndSquare(10, 5, 100); //≅ addAll(double(10), square(5), ramda.identity(100));
         * //=&gt; 225
         */</span>
        <span class="hljs-keyword">var</span> useWith = R.useWith = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_useWith</span><span class="hljs-params">(fn <span class="hljs-comment">/*, transformers */</span>)</span> </span>{
            <span class="hljs-keyword">var</span> transformers = _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">var</span> tlen = transformers.length;
            <span class="hljs-keyword">return</span> curry(arity(tlen, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> args = [], idx = -<span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (++idx &lt; tlen) {
                    args.push(transformers[idx](<span class="hljs-built_in">arguments</span>[idx]));
                }
                <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args.concat(_slice(<span class="hljs-built_in">arguments</span>, tlen)));
            }));
        };
        aliasFor(<span class="hljs-string">'useWith'</span>).is(<span class="hljs-string">'disperseTo'</span>);

        <span class="hljs-comment">/**
         * Iterate over an input `list`, calling a provided function `fn` for each element in the
         * list.
         *
         * `fn` receives one argument: *(value)*.
         *
         * Note: `ramda.each` does not skip deleted or unassigned indices (sparse arrays), unlike
         * the native `Array.prototype.forEach` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
         *
         * Also note that, unlike `Array.prototype.forEach`, Ramda's `each` returns the original
         * array.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function to invoke. Receives one argument, `value`.
         * @param {Array} list The list to iterate over.
         * @return {Array} The original list.
         * @example
         *
         * ramda.each(function(num) {
         *   console.log(num + 100);
         * }, [1, 2, 3]); //=&gt; [1, 2, 3]
         * //-&gt; 101
         * //-&gt; 102
         * //-&gt; 103
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                fn(list[idx]);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>i can’t bear not to return <em>something</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> list;
        }
        R.each = curry2(each);

        <span class="hljs-comment">/**
         * Like `each`, but but passes additional parameters to the predicate function.
         *
         * `fn` receives three arguments: *(value, index, list)*.
         *
         * Note: `ramda.each.idx` does not skip deleted or unassigned indices (sparse arrays),
         * unlike the native `Array.prototype.forEach` method. For more details on this behavior,
         * see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
         *
         * Also note that, unlike `Array.prototype.forEach`, Ramda's `each` returns the original
         * array.
         *
         * @static
         * @memberOf R
         * @category List
         * @alias forEach
         * @param {Function} fn The function to invoke. Receives three arguments: (`value`, `index`,
         * `list`).
         * @param {Array} list The list to iterate over.
         * @return {Array} The original list.
         * @example
         *
         * // Note that having access to the original `list` allows for mutation. While you *can* do
         * // this, it's very un-functional behavior:
         * ramda.each.idx(function(num, idx, list) {
         *   list[idx] = num + 100;
         * }, [1, 2, 3]); //=&gt; [101, 102, 103]
         */</span>
        R.each.idx = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eachIdx</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                fn(list[idx], idx, list);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>i can’t bear not to return <em>something</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> list;
        });
        aliasFor(<span class="hljs-string">"each"</span>).is(<span class="hljs-string">"forEach"</span>);

        <span class="hljs-comment">/**
         * Creates a shallow copy of an array.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {Array} list The list to clone.
         * @return {Array} A new copy of the original list.
         * @example
         *
         * var numbers = [1, 2, 3];
         * var numbersClone = ramda.clone(numbers); //=&gt; [1, 2, 3]
         * numbers === numbersClone; //=&gt; false
         *
         * // Note that this is a shallow clone--it does not clone complex values:
         * var objects = [{}, {}, {}];
         * var objectsClone = ramda.clone(objects);
         * objects[0] === objectsClone[0]; //=&gt; true
         */</span>
        <span class="hljs-keyword">var</span> clone = R.clone = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_clone</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">return</span> _slice(list);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h2 id="core-functions">Core Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * Reports whether an array is empty.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {Array} arr The array to consider.
         * @return {boolean} `true` if the `arr` argument has a length of 0 or if `arr` is a falsy
         * value (e.g. undefined).
         * @example
         *
         * ramda.isEmpty([1, 2, 3]); //=&gt; false
         * ramda.isEmpty([]); //=&gt; true
         * ramda.isEmpty(); //=&gt; true
         * ramda.isEmpty(null); //=&gt; true
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(arr)</span> </span>{
            <span class="hljs-keyword">return</span> !arr || !arr.length;
        }
        R.isEmpty = isEmpty;

        <span class="hljs-comment">/**
         * Returns a new list with the given element at the front, followed by the contents of the
         * list.
         *
         * @static
         * @memberOf R
         * @category Array
         * @alias cons
         * @param {*} el The item to add to the head of the output list.
         * @param {Array} arr The array to add to the tail of the output list.
         * @return {Array} A new array.
         * @example
         *
         * ramda.prepend('fee', ['fi', 'fo', 'fum']); //=&gt; ['fee', 'fi', 'fo', 'fum']
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepend</span><span class="hljs-params">(el, arr)</span> </span>{
            <span class="hljs-keyword">return</span> concat([el], arr);
        }
        R.prepend = prepend;
        aliasFor(<span class="hljs-string">"prepend"</span>).is(<span class="hljs-string">"cons"</span>);

        <span class="hljs-comment">/**
         * Returns the first element in a list.
         *
         * @static
         * @memberOf R
         * @category Array
         * @alias car, first
         * @param {Array} [arr=[]] The array to consider.
         * @return {*} The first element of the list, or `undefined` if the list is empty.
         * @example
         *
         * ramda.head(['fi', 'fo', 'fum']); //=&gt; 'fi'
         */</span>
        <span class="hljs-keyword">var</span> head = R.head = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_car</span><span class="hljs-params">(arr)</span> </span>{
            arr = arr || [];
            <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];
        };

        aliasFor(<span class="hljs-string">"head"</span>).is(<span class="hljs-string">"car"</span>).and(<span class="hljs-string">"first"</span>);

        <span class="hljs-comment">/**
         * Returns the last element from a list.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {Array} [arr=[]] The array to consider.
         * @return {*} The last element of the list, or `undefined` if the list is empty.
         * @example
         *
         * ramda.last(['fi', 'fo', 'fum']); //=&gt; 'fum'
         */</span>
        R.last = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_last</span><span class="hljs-params">(arr)</span> </span>{
            arr = arr || [];
            <span class="hljs-keyword">return</span> arr[arr.length - <span class="hljs-number">1</span>];
        };

        <span class="hljs-comment">/**
         * Returns all but the first element of a list. If the list provided has the `tail` method,
         * it will instead return `list.tail()`.
         *
         * @static
         * @memberOf R
         * @category Array
         * @alias cdr
         * @param {Array} [arr=[]] The array to consider.
         * @return {Array} A new array containing all but the first element of the input list, or an
         * empty list if the input list is a falsy value (e.g. `undefined`).
         * @example
         *
         * ramda.tail(['fi', 'fo', 'fum']); //=&gt; ['fo', 'fum']
         */</span>
        <span class="hljs-keyword">var</span> tail = R.tail = checkForMethod(<span class="hljs-string">'tail'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span> </span>{
            arr = arr || [];
            <span class="hljs-keyword">return</span> (arr.length &gt; <span class="hljs-number">1</span>) ? _slice(arr, <span class="hljs-number">1</span>) : [];
        });

        aliasFor(<span class="hljs-string">"tail"</span>).is(<span class="hljs-string">"cdr"</span>);

        <span class="hljs-comment">/**
         * Returns `true` if the argument is an atom; `false` otherwise. An atom is defined as any
         * value that is not an array, `undefined`, or `null`.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {*} x The element to consider.
         * @return {boolean} `true` if `x` is an atom, and `false` otherwise.
         * @example
         *
         * ramda.isAtom([]); //=&gt; false
         * ramda.isAtom(null); //=&gt; false
         * ramda.isAtom(undefined); //=&gt; false
         *
         * ramda.isAtom(0); //=&gt; true
         * ramda.isAtom(''); //=&gt; true
         * ramda.isAtom('test'); //=&gt; true
         * ramda.isAtom({}); //=&gt; true
         */</span>
        R.isAtom = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isAtom</span><span class="hljs-params">(x)</span> </span>{
            <span class="hljs-keyword">return</span> x != <span class="hljs-literal">null</span> &amp;&amp; !isArray(x);
        };

        <span class="hljs-comment">/**
         * Returns a new list containing the contents of the given list, followed by the given
         * element.
         *
         * @static
         * @memberOf R
         * @category Array
         * @alias push
         * @param {*} el The element to add to the end of the new list.
         * @param {Array} list The list whose contents will be added to the beginning of the output
         * list.
         * @return {Array} A new list containing the contents of the old list followed by `el`.
         * @example
         *
         * ramda.append('tests', ['write', 'more']); //=&gt; ['write', 'more', 'tests']
         * ramda.append('tests', []); //=&gt; ['tests']
         * ramda.append(['tests'], ['write', 'more']); //=&gt; ['write', 'more', ['tests']]
         */</span>
        <span class="hljs-keyword">var</span> append = R.append = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_append</span><span class="hljs-params">(el, list)</span> </span>{
            <span class="hljs-keyword">return</span> concat(list, [el]);
        };

        aliasFor(<span class="hljs-string">"append"</span>).is(<span class="hljs-string">"push"</span>);

        <span class="hljs-comment">/**
         * Returns a new list consisting of the elements of the first list followed by the elements
         * of the second.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {Array} list1 The first list to merge.
         * @param {Array} list2 The second set to merge.
         * @return {Array} A new array consisting of the contents of `list1` followed by the
         * contents of `list2`. If, instead of an {Array} for `list1`, you pass an object with a `concat`
         * method on it, `concat` will call `list1.concat` and it the value of `list2`.
         * @example
         *
         * ramda.concat([], []); //=&gt; []
         * ramda.concat([4, 5, 6], [1, 2, 3]); //=&gt; [4, 5, 6, 1, 2, 3]
         * ramda.concat("ABC", "DEF"); // "ABCDEF"
         */</span>
        R.concat = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(set1, set2)</span> </span>{
            <span class="hljs-keyword">return</span> (hasMethod(<span class="hljs-string">'concat'</span>, set1)) ? set1.concat(set2) : concat(set1, set2);
        });

        <span class="hljs-comment">/**
         * A function that does nothing but return the parameter supplied to it. Good as a default
         * or placeholder function.
         *
         * @static
         * @memberOf R
         * @category Core
         * @alias I
         * @param {*} x The value to return.
         * @return {*} The input value, `x`.
         * @example
         *
         * ramda.identity(1); //=&gt; 1
         *
         * var obj = {};
         * ramda.identity(obj) === obj; //=&gt; true
         */</span>
        <span class="hljs-keyword">var</span> identity = R.identity = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_I</span><span class="hljs-params">(x)</span> </span>{
            <span class="hljs-keyword">return</span> x;
        };
        aliasFor(<span class="hljs-string">"identity"</span>).is(<span class="hljs-string">"I"</span>);

        <span class="hljs-comment">/**
         * Calls an input function `n` times, returning an array containing the results of those
         * function calls.
         *
         * `fn` is passed one argument: The current value of `n`, which begins at `0` and is
         * gradually incremented to `n - 1`.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
         * @param {number} n A value between `0` and `n - 1`. Increments after each function call.
         * @return {Array} An array containing the return values of all calls to `fn`.
         * @example
         *
         * ramda.times(function(n) { return n; }, 5); //=&gt; [0, 1, 2, 3, 4]
         */</span>
        R.times = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_times</span><span class="hljs-params">(fn, n)</span> </span>{
            <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++i &lt; n) {
                arr[i] = fn(i);
            }
            <span class="hljs-keyword">return</span> arr;
        });


        <span class="hljs-comment">/**
         * Returns a fixed list of size `n` containing a specified identical value.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {*} value The value to repeat.
         * @param {number} n The desired size of the output list.
         * @return {Array} A new array containing `n` `value`s.
         * @example
         *
         * ramda.repeatN('hi', 5); //=&gt; ['hi', 'hi', 'hi', 'hi', 'hi']
         *
         * var obj = {};
         * var repeatedObjs = ramda.repeatN(obj, 5); //=&gt; [{}, {}, {}, {}, {}]
         * repeatedObjs[0] === repeatedObjs[1]; //=&gt; true
         */</span>
        R.repeatN = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_repeatN</span><span class="hljs-params">(value, n)</span> </span>{
            <span class="hljs-keyword">return</span> R.times(R.always(value), n);
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h2 id="function-functions-">Function functions :-)</h2>

            </div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>These functions make new functions out of old ones.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * Returns a new function which partially applies a value to a given function, where the
         * function is a variadic function that cannot be curried.
         *
         * @private
         * @category Function
         * @param {Function} f The function to partially apply `a` onto.
         * @param {*} a The argument to partially apply onto `f`.
         * @return {Function} A new function.
         * @example
         *
         * var addThree = function(a, b, c) {
         *   return a + b + c;
         * };
         * var partialAdd = partially(add, 1);
         * partialAdd(2, 3); //=&gt; 6
         *
         * // partialAdd is invoked immediately, even though it expects three arguments. This is
         * // because, unlike many functions here, the result of `partially` is not a curried
         * // function.
         * partialAdd(2); //≅ addThree(1, 2, undefined) =&gt; NaN
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partially</span><span class="hljs-params">(f, a)</span></span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> f.apply(<span class="hljs-keyword">this</span>, concat([a], <span class="hljs-built_in">arguments</span>));
            };
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * Basic, right-associative composition function. Accepts two functions and returns the
         * composite function; this composite function represents the operation `var h = f(g(x))`,
         * where `f` is the first argument, `g` is the second argument, and `x` is whatever
         * argument(s) are passed to `h`.
         *
         * This function's main use is to build the more general `compose` function, which accepts
         * any number of functions.
         *
         * @private
         * @category Function
         * @param {Function} f A function.
         * @param {Function} g A function.
         * @return {Function} A new function that is the equivalent of `f(g(x))`.
         * @example
         *
         * var double = function(x) { return x * 2; };
         * var square = function(x) { return x * x; };
         * var squareThenDouble = internalCompose(double, square);
         *
         * squareThenDouble(5); //≅ double(square(5)) =&gt; 50
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">internalCompose</span><span class="hljs-params">(f, g)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> f.call(<span class="hljs-keyword">this</span>, g.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
            };
        }

        <span class="hljs-comment">/**
         * Creates a new function that runs each of the functions supplied as parameters in turn,
         * passing the return value of each function invocation to the next function invocation,
         * beginning with whatever arguments were passed to the initial invocation.
         *
         * Note that `compose` is a right-associative function, which means the functions provided
         * will be invoked in order from right to left. In the example `var h = compose(f, g)`,
         * the function `h` is equivalent to `f( g(x) )`, where `x` represents the arguments
         * originally passed to `h`.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {...Function} functions A variable number of functions.
         * @return {Function} A new function which represents the result of calling each of the
         * input `functions`, passing the result of each function call to the next, from right to
         * left.
         * @example
         *
         * var triple = function(x) { return x * 3; };
         * var double = function(x) { return x * 2; };
         * var square = function(x) { return x * x; };
         * var squareThenDoubleThenTriple = ramda.compose(triple, double, square);
         *
         * squareThenDoubleThenTriple(5); //≅ triple(double(square(5))) =&gt; 150
         */</span>
        <span class="hljs-keyword">var</span> compose = R.compose = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_compose</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">// TODO: type check of arguments?</span>
            <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">throw</span> NO_ARGS_EXCEPTION;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">var</span> idx = <span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>, func = <span class="hljs-built_in">arguments</span>[idx], fnArity = func.length;
                    <span class="hljs-keyword">while</span> (idx--) {
                        func = internalCompose(<span class="hljs-built_in">arguments</span>[idx], func);
                    }
                    <span class="hljs-keyword">return</span> arity(fnArity, func);
            }
        };

        <span class="hljs-comment">/**
         * Creates a new function that runs each of the functions supplied as parameters in turn,
         * passing the return value of each function invocation to the next function invocation,
         * beginning with whatever arguments were passed to the initial invocation.
         *
         * `pipe` is the mirror version of `compose`. `pipe` is left-associative, which means that
         * each of the functions provided is executed in order from left to right.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {...Function} functions A variable number of functions.
         * @return {Function} A new function which represents the result of calling each of the
         * input `functions`, passing the result of each function call to the next, from right to
         * left.
         * @example
         *
         * var triple = function(x) { return x * 3; };
         * var double = function(x) { return x * 2; };
         * var square = function(x) { return x * x; };
         * var squareThenDoubleThenTriple = ramda.pipe(square, double, triple);
         *
         * squareThenDoubleThenTriple(5); //≅ triple(double(square(5))) =&gt; 150
         */</span>
        R.pipe = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_pipe</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">// TODO: type check of arguments?</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> partially (R.pipe, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]);
            }
            <span class="hljs-keyword">return</span> compose.apply(<span class="hljs-keyword">this</span>, _slice(<span class="hljs-built_in">arguments</span>).reverse());
        };
        aliasFor(<span class="hljs-string">"pipe"</span>).is(<span class="hljs-string">"sequence"</span>);

        <span class="hljs-comment">/**
         * Returns a new function much like the supplied one, except that the first two arguments'
         * order is reversed.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to invoke with its first two parameters reversed.
         * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
         * @example
         *
         * var mergeThree = function(a, b, c) {
         *   ([]).concat(a, b, c);
         * };
         * var numbers = [1, 2, 3];
         *
         * mergeThree(numbers); //=&gt; [1, 2, 3]
         *
         * ramda.flip([1, 2, 3]); //=&gt; [2, 1, 3]
         */</span>
        <span class="hljs-keyword">var</span> flip = R.flip = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_flip</span><span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ?
                  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, [b, a].concat(_slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>))); } :
                  fn.apply(<span class="hljs-keyword">this</span>, [b, a].concat(_slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>)));
            };
        };

        <span class="hljs-comment">/**
         * Accepts as its arguments a function and any number of values and returns a function that,
         * when invoked, calls the original function with all of the values prepended to the
         * original function's arguments list.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to invoke.
         * @param {...*} [args] Arguments to prepend to `fn` when the returned function is invoked.
         * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn`
         * with `args` prepended to `fn`'s arguments list.
         * @example
         *
         * var multiply = function(a, b) { return a * b; };
         * var double = ramda.lPartial(multiply, 2);
         *
         * double(2); //=&gt; 4
         *
         *
         * var greet = function(salutation, title, firstName, lastName) {
         *   return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
         * };
         * var sayHello = ramda.lPartial(greet, 'Hello');
         * var sayHelloToMs = ramda.lPartial(sayHello, 'Ms.');
         *
         * sayHelloToMs('Jane', 'Jones'); //=&gt; 'Hello, Ms. Jane Jones!'
         */</span>
        R.lPartial = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_lPartial</span><span class="hljs-params">(fn <span class="hljs-comment">/*, args */</span>)</span> </span>{
            <span class="hljs-keyword">var</span> args = _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> arity(<span class="hljs-built_in">Math</span>.max(fn.length - args.length, <span class="hljs-number">0</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, concat(args, <span class="hljs-built_in">arguments</span>));
            });
        };
        aliasFor(<span class="hljs-string">"lPartial"</span>).is(<span class="hljs-string">"applyLeft"</span>);

        <span class="hljs-comment">/**
         * Accepts as its arguments a function and any number of values and returns a function that,
         * when invoked, calls the original function with all of the values appended to the original
         * function's arguments list.
         *
         * Note that `rPartial` is the opposite of `lPartial`: `rPartial` fills `fn`'s arguments
         * from the right to the left.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to invoke.
         * @param {...*} [args] Arguments to append to `fn` when the returned function is invoked.
         * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn` with
         * `args` appended to `fn`'s arguments list.
         * @example
         *
         * var greet = function(salutation, title, firstName, lastName) {
         *   return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
         * };
         * var greetMsJaneJones = ramda.rPartial(greet, 'Ms.', 'Jane', 'Jones');
         *
         * greetMsJaneJones('Hello'); //=&gt; 'Hello, Ms. Jane Jones!'
         */</span>
        R.rPartial = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_rPartial</span><span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">var</span> args = _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> arity(<span class="hljs-built_in">Math</span>.max(fn.length - args.length, <span class="hljs-number">0</span>), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, concat(<span class="hljs-built_in">arguments</span>, args));
            });
        };
        aliasFor(<span class="hljs-string">"rPartial"</span>).is(<span class="hljs-string">"applyRight"</span>);

        <span class="hljs-comment">/**
         * Creates a new function that, when invoked, caches the result of calling `fn` for a given
         * argument set and returns the result. Subsequent calls to the memoized `fn` with the same
         * argument set will not result in an additional call to `fn`; instead, the cached result
         * for that set of arguments will be returned.
         *
         * Note that this version of `memoize` effectively handles only string and number
         * parameters.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to be wrapped by `memoize`.
         * @return {Function}  Returns a memoized version of `fn`.
         * @example
         *
         * var numberOfCalls = 0;
         * var tracedAdd = function(a, b) {
         *   numberOfCalls += 1;
         *   return a + b;
         * };
         * var memoTrackedAdd = ramda.memoize(trackedAdd);
         *
         * memoAdd(1, 2); //=&gt; 3 (numberOfCalls =&gt; 1)
         * memoAdd(1, 2); //=&gt; 3 (numberOfCalls =&gt; 1)
         * memoAdd(2, 3); //=&gt; 5 (numberOfCalls =&gt; 2)
         *
         * // Note that argument order matters
         * memoAdd(2, 1); //=&gt; 3 (numberOfCalls =&gt; 3)
         */</span>
        R.memoize = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_memoize</span><span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">var</span> cache = {};
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> position = foldl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cache, arg)</span> </span>{
                        <span class="hljs-keyword">return</span> cache[arg] || (cache[arg] = {});
                    }, cache,
                    _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>));
                <span class="hljs-keyword">var</span> arg = <span class="hljs-built_in">arguments</span>[<span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>];
                <span class="hljs-keyword">return</span> (position[arg] || (position[arg] = fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)));
            };
        };

        <span class="hljs-comment">/**
         * Accepts a function `fn` and returns a function that guards invocation of `fn` such that
         * `fn` can only ever be called once, no matter how many times the returned function is
         * invoked.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to wrap in a call-only-once wrapper.
         * @return {Function} The wrapped function.
         * @example
         *
         * var alertOnce = ramda.once(alert);
         * alertOnce('Hello!'); // Alerts 'Hello!'
         * alertOnce('Nothing'); // Doesn't alert
         * alertOnce('Again'); // Doesn't alert
         */</span>
        R.once = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_once</span><span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">var</span> called = <span class="hljs-literal">false</span>, result;
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">if</span> (called) {
                    <span class="hljs-keyword">return</span> result;
                }
                called = <span class="hljs-literal">true</span>;
                result = fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                <span class="hljs-keyword">return</span> result;
            };
        };

        <span class="hljs-comment">/**
         * Wrap a function inside another to allow you to make adjustments to the parameters, or do
         * other processing either before the internal function is called or with its results.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to wrap.
         * @param {Function} wrapper The wrapper function.
         * @return {Function} The wrapped function.
         * @example
         *
         * var slashify = wrap(flip(add)('/'), function(f, x) {
         *  return match(/\/$/)(x) ? x : f(x)
         * });
         *
         * slashify("a") //= "a/"
         * slashify("a/") //= "a/"
         */</span>
        R.wrap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_wrap</span><span class="hljs-params">(fn, wrapper)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> wrapper.apply(<span class="hljs-keyword">this</span>, concat([fn], <span class="hljs-built_in">arguments</span>));
            };
        };

        <span class="hljs-comment">/**
         * Wraps a constructor function inside a curried function that can be called with the same
         * arguments and returns the same type.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} Fn The constructor function to wrap.
         * @return {Function} A wrapped, curried constructor function.
         * @example
         *
         * // Constructor function
         * var Widget = function(config) {
         *   // ...
         * };
         * Widget.prototype = {
         *   // ...
         * };
         * map(construct(Widget), allConfigs); //=&gt; a list of Widgets
         */</span>
        R.construct = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_construct</span><span class="hljs-params">(Fn)</span> </span>{
            <span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Fn();
                Fn.apply(obj, <span class="hljs-built_in">arguments</span>);
                <span class="hljs-keyword">return</span> obj;
            };
            <span class="hljs-keyword">return</span> Fn.length &gt; <span class="hljs-number">1</span> ? curry(nAry(Fn.length, f)) : f;
        };

        <span class="hljs-comment">/**
         * Accepts three functions and returns a new function. When invoked, this new function will
         * invoke the first function, `after`, passing as its arguments the results of invoking the
         * second and third functions with whatever arguments are passed to the new function.
         *
         * For example, a function produced by `fork` is equivalent to:
         *
         * ```javascript
         *   var h = ramda.fork(e, f, g);
         *   h(1, 2); //≅ e( f(1, 2), g(1, 2) )
         * ```
         *
         * @static
         * @memberOf R
         * @category
         * @param {Function} after A function. `after` will be invoked with the return values of
         * `fn1` and `fn2` as its arguments.
         * @param {Function} fn1 A function. It will be invoked with the arguments passed to the
         * returned function. Afterward, its resulting value will be passed to `after` as its first
         * argument.
         * @param {Function} fn2 A function. It will be invoked with the arguments passed to the
         * returned function. Afterward, its resulting value will be passed to `after` as its second
         * argument.
         * @return {Function} A new function.
         * @example
         *
         * var add = function(a, b) { return a + b; };
         * var multiply = function(a, b) { return a * b; };
         * var subtract = function(a, b) { return a - b; };
         *
         * ramda.fork(multiply, add, subtract)(1, 2);
         * //≅ multiply( add(1, 2), subtract(1, 2) );
         * //=&gt; -3
         */</span>
        R.fork = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(after)</span> </span>{
            <span class="hljs-keyword">var</span> fns = _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
                <span class="hljs-keyword">return</span> after.apply(<span class="hljs-keyword">this</span>, map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{
                    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args);
                }, fns));
            };
        };
        aliasFor(<span class="hljs-string">'fork'</span>).is(<span class="hljs-string">'distributeTo'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h2 id="list-functions">List Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>These functions operate on logical lists, here plain arrays.  Almost all of these are curried, and the list
parameter comes last, so you can create a new function by supplying the preceding arguments, leaving the
list parameter off.  For instance:</p>
<pre><code><span class="hljs-comment">// skip third parameter</span>
<span class="hljs-keyword">var</span> checkAllPredicates = reduce(andFn, alwaysTrue);
<span class="hljs-comment">// ... given suitable definitions of odd, lt20, gt5</span>
<span class="hljs-keyword">var</span> test = checkAllPredicates([odd, lt20, gt5]);
<span class="hljs-comment">// test(7) =&gt; true, test(9) =&gt; true, test(10) =&gt; false,</span>
<span class="hljs-comment">// test(3) =&gt; false, test(21) =&gt; false,</span>
</code></pre>
            </div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * Returns a single item by iterating through the list, successively calling the iterator
         * function and passing it an accumulator value and the current value from the array, and
         * then passing the result to the next call.
         *
         * The iterator function receives two values: *(acc, value)*
         *
         * Note: `ramda.foldl` does not skip deleted or unassigned indices (sparse arrays), unlike
         * the native `Array.prototype.reduce` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @alias reduce
         * @param {Function} fn The iterator function. Receives two values, the accumulator and the
         * current element from the array.
         * @param {*} acc The accumulator value.
         * @param {Array} list The list to iterate over.
         * @return {*} The final, accumulated value.
         * @example
         *
         * var numbers = [1, 2, 3];
         * var add = function(a, b) {
         *   return a + b;
         * };
         *
         * foldl(numbers, add, 10); //=&gt; 16
         */</span>
        <span class="hljs-keyword">var</span> foldl = R.foldl =  curry3(checkForMethod(<span class="hljs-string">'foldl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, acc, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                acc = fn(acc, list[idx]);
            }
            <span class="hljs-keyword">return</span> acc;
        }));
        aliasFor(<span class="hljs-string">"foldl"</span>).is(<span class="hljs-string">"reduce"</span>);

        <span class="hljs-comment">/**
         * Like `foldl`, but passes additional parameters to the predicate function.
         *
         * The iterator function receives four values: *(acc, value, index, list)*
         *
         * Note: `ramda.foldl.idx` does not skip deleted or unassigned indices (sparse arrays),
         * unlike the native `Array.prototype.reduce` method. For more details on this behavior,
         * see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The iterator function. Receives four values: the accumulator, the
         * current element from `list`, that element's index, and the entire `list` itself.
         * @param {*} acc The accumulator value.
         * @param {Array} list The list to iterate over.
         * @return {*} The final, accumulated value.
         * @example
         *
         * var letters = ['a', 'b', 'c'];
         * var objectify = function(accObject, elem, idx, list) {
         *   return accObject[elem] = idx;
         * };
         *
         * foldl.idx(letters, objectify, {}); //=&gt; { 'a': 0, 'b': 1, 'c': 2 }
         */</span>
        R.foldl.idx = curry3(checkForMethod(<span class="hljs-string">'foldl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, acc, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                acc = fn(acc, list[idx], idx, list);
            }
            <span class="hljs-keyword">return</span> acc;
        }));

        <span class="hljs-comment">/**
         * Returns a single item by iterating through the list, successively calling the iterator
         * function and passing it an accumulator value and the current value from the array, and
         * then passing the result to the next call.
         *
         * Similar to `foldl`, except moves through the input list from the right to the left.
         *
         * The iterator function receives two values: *(acc, value)*
         *
         * Note: `ramda.foldr` does not skip deleted or unassigned indices (sparse arrays), unlike
         * the native `Array.prototype.reduce` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @alias reduceRight
         * @param {Function} fn The iterator function. Receives two values, the accumulator and the
         * current element from the array.
         * @param {*} acc The accumulator value.
         * @param {Array} list The list to iterate over.
         * @return {*} The final, accumulated value.
         * @example
         *
         * var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
         * var flattenPairs = function(acc, pair) {
         *   return acc.concat(pair);
         * };
         *
         * foldr(numbers, flattenPairs, []); //=&gt; [ 'c', 3, 'b', 2, 'a', 1 ]
         */</span>
        <span class="hljs-keyword">var</span> foldr = R.foldr = curry3(checkForMethod(<span class="hljs-string">'foldr'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, acc, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = list.length;
            <span class="hljs-keyword">while</span> (idx--) {
                acc = fn(acc, list[idx]);
            }
            <span class="hljs-keyword">return</span> acc;
        }));
        aliasFor(<span class="hljs-string">"foldr"</span>).is(<span class="hljs-string">"reduceRight"</span>);

        <span class="hljs-comment">/**
         * Like `foldr`, but passes additional parameters to the predicate function. Moves through
         * the input list from the right to the left.
         *
         * The iterator function receives four values: *(acc, value, index, list)*.
         *
         * Note: `ramda.foldr.idx` does not skip deleted or unassigned indices (sparse arrays),
         * unlike the native `Array.prototype.reduce` method. For more details on this behavior,
         * see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The iterator function. Receives four values: the accumulator, the
         * current element from `list`, that element's index, and the entire `list` itself.
         * @param {*} acc The accumulator value.
         * @param {Array} list The list to iterate over.
         * @return {*} The final, accumulated value.
         * @example
         *
         * var letters = ['a', 'b', 'c'];
         * var objectify = function(accObject, elem, idx, list) {
         *   return accObject[elem] = idx;
         * };
         *
         * foldr.idx(letters, objectify, {}); //=&gt; { 'c': 2, 'b': 1, 'a': 0 }
         */</span>
        R.foldr.idx = curry3(checkForMethod(<span class="hljs-string">'foldr'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, acc, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = list.length;
            <span class="hljs-keyword">while</span> (idx--) {
                acc = fn(acc, list[idx], idx, list);
            }
            <span class="hljs-keyword">return</span> acc;
        }));

        <span class="hljs-comment">/**
         * Builds a list from a seed value. Accepts an iterator function, which returns either false
         * to stop iteration or an array of length 2 containing the value to add to the resulting
         * list and the seed to be used in the next call to the iterator function.
         *
         * The iterator function receives one argument: *(seed)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
         * either false to quit iteration or an array of length two to proceed. The element at index
         * 0 of this array will be added to the resulting array, and the element at index 1 will be
         * passed to the next call to `fn`.
         * @param {*} seed The seed value.
         * @return {Array} The final list.
         * @example
         *
         * var f = function(n) { return n &gt; 50 ? false : [-n, n + 10] };
         * unfoldr(f, 10) //= [-10, -20, -30, -40, -50]
         */</span>
        R.unfoldr = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unfoldr</span><span class="hljs-params">(fn, seed)</span> </span>{
            <span class="hljs-keyword">var</span> pair = fn(seed);
            <span class="hljs-keyword">var</span> result = [];
            <span class="hljs-keyword">while</span> (pair &amp;&amp; pair.length) {
                result.push(pair[<span class="hljs-number">0</span>]);
                pair = fn(pair[<span class="hljs-number">1</span>]);
            }
            <span class="hljs-keyword">return</span> result;
        });

        <span class="hljs-comment">/**
         * Returns a new list, constructed by applying the supplied function to every element of the
         * supplied list.
         *
         * Note: `ramda.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
         * native `Array.prototype.map` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function to be called on every element of the input `list`.
         * @param {Array} list The list to be iterated over.
         * @return {Array} The new list.
         * @example
         *
         * var double = function(x) {
         *   return x * 2;
         * };
         *
         * ramda.map(double, [1, 2, 3]); //=&gt; [2, 4, 6]
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length, result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                result[idx] = fn(list[idx]);
            }
            <span class="hljs-keyword">return</span> result;
        }
        R.map = curry2(checkForMethod(<span class="hljs-string">'map'</span>, map));

        <span class="hljs-comment">/**
         * Like `map`, but but passes additional parameters to the predicate function.
         *
         * `fn` receives three arguments: *(value, index, list)*.
         *
         * Note: `ramda.map.idx` does not skip deleted or unassigned indices (sparse arrays), unlike
         * the native `Array.prototype.map` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function to be called on every element of the input `list`.
         * @param {Array} list The list to be iterated over.
         * @return {Array} The new list.
         * @example
         *
         * var squareEnds = function(elt, idx, list) {
         *   if (idx === 0 || idx === list.length - 1) {
         *     return elt * elt;
         *   }
         *   return elt;
         * };
         *
         * ramda.map.idx(squareEnds, [8, 6, 7, 5, 3, 0, 9];
         * //=&gt; [64, 6, 7, 5, 3, 0, 81]
         */</span>
        R.map.idx = curry2(checkForMethod(<span class="hljs-string">'map'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_mapIdx</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length, result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                result[idx] = fn(list[idx], idx, list);
            }
            <span class="hljs-keyword">return</span> result;
        }));

        <span class="hljs-comment">/**
         * Map, but for objects. Creates an object with the same keys as `obj` and values
         * generated by running each property of `obj` through `fn`. `fn` is passed one argument:
         * *(value)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} fn A function called for each property in `obj`. Its return value will
         * become a new property on the return object.
         * @param {Object} obj The object to iterate over.
         * @return {Object} A new object with the same keys as `obj` and values that are the result
         * of running each property through `fn`.
         * @example
         *
         * var values = { x: 1, y: 2, z: 3 };
         * var double = function(num) {
         *   return num * 2;
         * };
         *
         * ramda.mapObj(double, values); //=&gt; { x: 2, y: 4, z: 6 }
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>TODO: consider mapObj.key in parallel with mapObj.idx.  Also consider folding together with <code>map</code> implementation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.mapObj = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_mapObject</span><span class="hljs-params">(fn, obj)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(acc, key)</span> </span>{
                acc[key] = fn(obj[key]);
                <span class="hljs-keyword">return</span> acc;
            }, {}, keys(obj));
        });

        <span class="hljs-comment">/**
         * Like `mapObj`, but but passes additional arguments to the predicate function. The
         * predicate function is passed three arguments: *(value, key, obj)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} fn A function called for each property in `obj`. Its return value will
         * become a new property on the return object.
         * @param {Object} obj The object to iterate over.
         * @return {Object} A new object with the same keys as `obj` and values that are the result
         * of running each property through `fn`.
         * @example
         *
         * var values = { x: 1, y: 2, z: 3 };
         * var double = function(num, key, obj) {
         *   return key + num;
         * };
         *
         * ramda.mapObj(double, values); //=&gt; { x: 'x2', y: 'y4', z: 'z6' }
         */</span>
        R.mapObj.idx = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapObjectIdx</span><span class="hljs-params">(fn, obj)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(acc, key)</span> </span>{
                acc[key] = fn(obj[key], key, obj);
                <span class="hljs-keyword">return</span> acc;
            }, {}, keys(obj));
        });

        <span class="hljs-comment">/**
         * ap applies a list of functions to a list of values.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Array} fns An array of functions
         * @param {Array} vs An array of values
         * @return the value of applying each the function `fns` to each value in `vs`
         * @example
         *
         * R.ap([R.multiply(2), R.add(3), [1,2,3]); //=&gt; [2, 4, 6, 4, 5, 6]
         */</span>
        R.ap = curry2(checkForMethod(<span class="hljs-string">'ap'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_ap</span><span class="hljs-params">(fns, vs)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(acc, fn)</span> </span>{
                <span class="hljs-keyword">return</span> concat(acc, map(fn, vs));
            },  [], fns);
        }));

        <span class="hljs-comment">/**
         *
         * `of` wraps any object in an Array. This implementation is compatible with the
         * Fantasy-land Applicative spec, and will work with types that implement that spec.
         * Note this `of` is different from the ES6 `of`; See
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
         *
         * @static
         * @memberOf R
         * @category Function
         * @param x any value
         * @return [x]
         * @example
         *
         * R.of(1); // =&gt; [1]
         * R.of([2]); // =&gt; [[2]]
         * R.of({}); // =&gt; [{}]
         *
         */</span>
        R.of = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_of</span><span class="hljs-params">(x, container)</span> </span>{
            <span class="hljs-keyword">return</span> (hasMethod(<span class="hljs-string">'of'</span>, container)) ? container.of(x) : [x];
        };

        <span class="hljs-comment">/**
         * `empty` wraps any object in an array. This implementation is compatible with the
         * Fantasy-land Monoid spec, and will work with types that implement that spec.
         *
         * @static
         * @memberOf R
         * @category Function
         * @return {Array} an empty array
         * @example
         *
         * R.empty([1,2,3,4,5]); // =&gt; []
         */</span>
        R.empty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_empty</span><span class="hljs-params">(x)</span> </span>{
            <span class="hljs-keyword">return</span> (hasMethod(<span class="hljs-string">'empty'</span>, x)) ? x.empty() : [];
        };


        <span class="hljs-comment">/**
         * `chain` takes a function that maps a nested list to a nested list and a nested list.
         * It maps the function over the nested list and then flattens the result (one level deep,
         * i.e. not recursively).
         * This implementatiou is compatible with the
         * Fantasy-land Chain spec, and will work with types that implement that spec.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function}
         * @param {Array} a nested array
         * @return {Array}
         *
         * @eaxmple
         *
         * R.chain(R.map(R.multiply(2)), [[1,2,3], [1], [0, -3]]); // =&gt; [2,4,6,2,0,-6]
         *
         */</span>
        R.chain = curry2(checkForMethod(<span class="hljs-string">'chain'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_chain</span><span class="hljs-params">(f, nestedList)</span> </span>{
            <span class="hljs-keyword">return</span> unnest(map(f, nestedList));
        }));
        aliasFor(<span class="hljs-string">'chain'</span>).is(<span class="hljs-string">'flatMap'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Reports the number of elements in the list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/**
         * Returns the number of elements in the array by returning `arr.length`.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} arr The array to inspect.
         * @return {number} The size of the array.
         * @example
         *
         * ramda.size([]); //=&gt; 0
         * ramda.size([1, 2, 3]); //=&gt; 3
         */</span>
        R.size = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_size</span><span class="hljs-params">(arr)</span> </span>{
            <span class="hljs-keyword">return</span> arr.length;
        };
        aliasFor(<span class="hljs-string">'size'</span>).is(<span class="hljs-string">'length'</span>);

        <span class="hljs-comment">/**
         * Returns a new list containing only those items that match a given predicate function.
         * The predicate function is passed one argument: *(value)*.
         *
         * Note that `ramda.filter` does not skip deleted or unassigned indices, unlike the native
         * `Array.prototype.filter` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} The new filtered array.
         * @example
         *
         * var isEven = function(n) {
         *     return n % 2 === 0;
         * };
         * var evens = ramda.filter(isEven, [1, 2, 3, 4]); // =&gt; [2, 4]
         */</span>
        <span class="hljs-keyword">var</span> filter = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_filter</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length, result = [];
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                <span class="hljs-keyword">if</span> (fn(list[idx])) {
                    result.push(list[idx]);
                }
            }
            <span class="hljs-keyword">return</span> result;
        };

        R.filter = curry2(checkForMethod(<span class="hljs-string">'filter'</span>, filter));

        <span class="hljs-comment">/**
         * Like `filter`, but passes additional parameters to the predicate function. The predicate
         * function is passed three arguments: *(value, index, list)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} The new filtered array.
         * @example
         *
         * var lastTwo = function(val, idx, list) {
         *     return list.length - idx &lt;= 2;
         * };
         * ramda.filter.idx(lastTwo, [8, 6, 7, 5, 3, 0, 9]); //=&gt; [0, 9]
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterIdx</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length, result = [];
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                <span class="hljs-keyword">if</span> (fn(list[idx], idx, list)) {
                    result.push(list[idx]);
                }
            }
            <span class="hljs-keyword">return</span> result;
        }
        R.filter.idx = curry2(checkForMethod(<span class="hljs-string">'filter'</span>, filterIdx));

        <span class="hljs-comment">/**
         * Similar to `filter`, except that it keeps only values for which the given predicate
         * function returns falsy. The predicate function is passed one argument: *(value)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} The new filtered array.
         * @example
         *
         * var isEven = function(n) {
         *     return n % 2 === 0;
         * };
         * var odds = ramda.reject(isOdd, [1, 2, 3, 4]); // =&gt; [2, 4]
         */</span>
        <span class="hljs-keyword">var</span> reject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_reject</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">return</span> filter(not(fn), list);
        };

        R.reject = curry2(reject);

        <span class="hljs-comment">/**
         * Like `reject`, but passes additional parameters to the predicate function. The predicate
         * function is passed three arguments: *(value, index, list)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} The new filtered array.
         * @example
         *
         * var lastTwo = function(val, idx, list) {
         *     return list.length - idx &lt;= 2;
         * };
         *
         * reject.idx(lastTwo, [8, 6, 7, 5, 3, 0, 9]); //=&gt; [8, 6, 7, 5, 3]
         */</span>
        R.reject.idx = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_rejectIdx</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">return</span> filterIdx(not(fn), list);
        });

        <span class="hljs-comment">/**
         * Returns a new list containing the first `n` elements of a given list, passing each value
         * to the supplied predicate function, and terminating when the predicate function returns
         * `false`. Excludes the element that caused the predicate function to fail. The predicate
         * function is passed one argument: *(value)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} A new array.
         * @example
         *
         * var isNotFour = function(x) {
         *   return !(x === 4);
         * };
         *
         * takeWhile(isNotFour, [1, 2, 3, 4]); //=&gt; [1, 2, 3]
         */</span>
        R.takeWhile = curry2(checkForMethod(<span class="hljs-string">'takeWhile'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len &amp;&amp; fn(list[idx])) {}
            <span class="hljs-keyword">return</span> _slice(list, <span class="hljs-number">0</span>, idx);
        }));


        <span class="hljs-comment">/**
         * Returns a new list containing the first `n` elements of the given list.  If
         * `n &gt; * list.length`, returns a list of `list.length` elements.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {number} n The number of elements to return.
         * @param {Array} list The array to query.
         * @return {Array} A new array containing the first elements of `list`.
         */</span>
        R.take = curry2(checkForMethod(<span class="hljs-string">'take'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n, list)</span> </span>{
            <span class="hljs-keyword">return</span> _slice(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(n, list.length));
        }));

        <span class="hljs-comment">/**
         * Returns a new list containing the last `n` elements of a given list, passing each value
         * to the supplied predicate function, beginning when the predicate function returns
         * `true`. Excludes the element that caused the predicate function to fail. The predicate
         * function is passed one argument: *(value)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} A new array.
         * @example
         *
         * var isNotTwo = function(x) {
         *   return !(x === 2);
         * };
         *
         * skipUntil(isNotFour, [1, 2, 3, 4]); //=&gt; [1, 2, 3]
         */</span>
        R.skipUntil = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_skipUntil</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len &amp;&amp; !fn(list[idx])) {}
            <span class="hljs-keyword">return</span> _slice(list, idx);
        });

        <span class="hljs-comment">/**
         * Returns a new list containing all but the first `n` elements of the given `list`.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {number} n The number of elements of `list` to skip.
         * @param {Array} list The array to consider.
         * @return {Array} The last `n` elements of `list`.
         */</span>
        R.skip = curry2(checkForMethod(<span class="hljs-string">'skip'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_skip</span><span class="hljs-params">(n, list)</span> </span>{
            <span class="hljs-keyword">return</span> _slice(list, n);
        }));
        aliasFor(<span class="hljs-string">'skip'</span>).is(<span class="hljs-string">'drop'</span>);

        <span class="hljs-comment">/**
         * Returns the first element of the list which matches the predicate, or `undefined` if no
         * element matches.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The predicate function used to determine if the element is the
         * desired one.
         * @param {Array} list The array to consider.
         * @return {Object} The element found, or `undefined`.
         * @example
         *
         * var xs = [{a: 1}, {a: 2}, {a: 3}];
         * find(propEq("a", 2))(xs); //= {a: 2}
         * find(propEq("a", 4))(xs); //= undefined
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Returns the first element of the list which matches the predicate, or <code>undefined</code> if no element matches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.find = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                <span class="hljs-keyword">if</span> (fn(list[idx])) {
                    <span class="hljs-keyword">return</span> list[idx];
                }
            }
        });

        <span class="hljs-comment">/**
         * Returns the index of the first element of the list which matches the predicate, or `-1`
         * if no element matches.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The predicate function used to determine if the element is the
         * desired one.
         * @param {Array} list The array to consider.
         * @return {number} The index of the element found, or `-1`.
         * @example
         *
         * var xs = [{a: 1}, {a: 2}, {a: 3}];
         * find(propEq("a", 2))(xs); //= 1
         * find(propEq("a", 4))(xs); //= -1
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Returns the index of first element of the list which matches the predicate, or <code>-1</code> if no
element matches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.findIndex = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_findIndex</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                <span class="hljs-keyword">if</span> (fn(list[idx])) {
                    <span class="hljs-keyword">return</span> idx;
                }
            }
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        });

        <span class="hljs-comment">/**
         * Returns the last element of the list which matches the predicate, or `undefined` if no
         * element matches.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The predicate function used to determine if the element is the
         * desired one.
         * @param {Array} list The array to consider.
         * @return {Object} The element found, or `undefined`.
         * @example
         *
         * var xs = [{a: 1, b: 0}, {a:1, b: 1}];
         * findLast(propEq("a", 1))(xs); //= {a: 1, b: 1}
         * findLast(propEq("a", 4))(xs); //= undefined
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Returns the last element of the list which matches the predicate, or <code>undefined</code> if no
element matches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.findLast = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_findLast</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = list.length;
            <span class="hljs-keyword">while</span> (--idx) {
                <span class="hljs-keyword">if</span> (fn(list[idx])) {
                    <span class="hljs-keyword">return</span> list[idx];
                }
            }
        });

        <span class="hljs-comment">/**
         * Returns the index of the last element of the list which matches the predicate, or
         * `-1` if no element matches.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The predicate function used to determine if the element is the
         * desired one.
         * @param {Array} list The array to consider.
         * @return {number} The index of the element found, or `-1`.
         * @example
         *
         * var xs = [{a: 1, b: 0}, {a:1, b: 1}];
         * findLastIndex(propEq("a", 1))(xs); //= 1
         * findLastIndex(propEq("a", 4))(xs); //= -1
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Returns the last element of the list which matches the predicate, or <code>undefined</code> if no
element matches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.findLastIndex = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_findLastIndex</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = list.length;
            <span class="hljs-keyword">while</span> (--idx) {
                <span class="hljs-keyword">if</span> (fn(list[idx])) {
                    <span class="hljs-keyword">return</span> idx;
                }
            }
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        });

        <span class="hljs-comment">/**
         * Returns `true` if all elements of the list match the predicate, `false` if there are any
         * that don't.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The predicate function.
         * @param {Array} list The array to consider.
         * @return {boolean} `true` if the predicate is satisfied by every element, `false`
         * otherwise
         * @example
         *
         * var lessThan2 = flip(lt)(2);
         * var lessThan3 = flip(lt)(3);
         * var xs = range(1, 3); //= [1, 2]
         * all(lessThan2)(xs); //= false
         * all(lessThan3)(xs); //= true
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Returns <code>true</code> if all elements of the list match the predicate, <code>false</code> if there are any
that don’t.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">all</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++i &lt; list.length) {
                <span class="hljs-keyword">if</span> (!fn(list[i])) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        R.all = curry2(all);
        aliasFor(<span class="hljs-string">"all"</span>).is(<span class="hljs-string">"every"</span>);

        <span class="hljs-comment">/**
         * Returns `true` if at least one of elements of the list match the predicate, `false`
         * otherwise.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The predicate function.
         * @param {Array} list The array to consider.
         * @return {boolean} `true` if the predicate is satisfied by at least one element, `false`
         * otherwise
         * @example
         *
         * var lessThan0 = flip(lt)(0);
         * var lessThan2 = flip(lt)(2);
         * var xs = range(1, 3); //= [1, 2]
         * any(lessThan0)(xs); //= false
         * any(lessThan2)(xs); //= true
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">any</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++i &lt; list.length) {
                <span class="hljs-keyword">if</span> (fn(list[i])) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        R.any = curry2(any);
        aliasFor(<span class="hljs-string">"any"</span>).is(<span class="hljs-string">"some"</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Internal implementations of indexOf and lastIndexOf</p>

            </div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Return the position of the first occurrence of an item in an array,
or -1 if the item is not included in the array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_indexOf</span><span class="hljs-params">(array, item, from)</span> </span>{
            <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, length = array.length;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> from == <span class="hljs-string">'number'</span>) {
                i = from &lt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, length + from) : from;
            }
            <span class="hljs-keyword">for</span> (; i &lt; length; i++) {
                <span class="hljs-keyword">if</span> (array[i] === item) <span class="hljs-keyword">return</span> i;
            }
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        <span class="hljs-keyword">var</span> lastIndexOf = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_lastIndexOf</span><span class="hljs-params">(array, item, from)</span> </span>{
            <span class="hljs-keyword">var</span> idx = array.length;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> from == <span class="hljs-string">'number'</span>) {
                idx = from &lt; <span class="hljs-number">0</span> ? idx + from + <span class="hljs-number">1</span> : <span class="hljs-built_in">Math</span>.min(idx, from + <span class="hljs-number">1</span>);
            }
            <span class="hljs-keyword">while</span> (--idx &gt;= <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (array[idx] === item) <span class="hljs-keyword">return</span> idx;
            }
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Returns the first zero-indexed position of an object in a flat list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.indexOf = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_indexOf</span><span class="hljs-params">(target, list)</span> </span>{
            <span class="hljs-keyword">return</span> indexOf(list, target);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.indexOf.from = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexOfFrom</span><span class="hljs-params">(target, fromIdx, list)</span> </span>{
            <span class="hljs-keyword">return</span> indexOf(list, target, fromIdx);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Returns the last zero-indexed position of an object in a flat list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.lastIndexOf = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_lastIndexOf</span><span class="hljs-params">(target, list)</span> </span>{
            <span class="hljs-keyword">return</span> lastIndexOf(list, target);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.lastIndexOf.from = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastIndexOfFrom</span><span class="hljs-params">(target, fromIdx, list)</span> </span>{
            <span class="hljs-keyword">return</span> lastIndexOf(list, target, fromIdx);
        });

        <span class="hljs-comment">/**
         * Returns `true` if the specified item is somewhere in the list, `false` otherwise.
         * Equivalent to `indexOf(a)(list) &gt; -1`. Uses strict (`===`) equality checking.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Object} a The item to compare against.
         * @param {Array} list The array to consider.
         * @return {boolean} `true` if the item is in the list, `false` otherwise.
         * @example
         *
         * contains(3)([1, 2, 3]); //= true
         * contains(4)([1, 2, 3]); //= false
         * contains({})([{}, {}]); //= false
         * var obj = {};
         * contains(obj)([{}, obj, {}]); //= true
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Returns <code>true</code> if the list contains the sought element, <code>false</code> if it does not.  Equality
is strict here, meaning reference equality for objects and non-coercing equality for
primitives.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span><span class="hljs-params">(a, list)</span> </span>{
            <span class="hljs-keyword">return</span> indexOf(list, a) &gt; -<span class="hljs-number">1</span>;
        }
        R.contains = curry2(contains);


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Returns <code>true</code> if the list contains the sought element, <code>false</code> if it does not, based upon the value
returned by applying the supplied predicated to two list elements.  Equality is strict here, meaning
reference equality for objects and non-coercing equality for primitives.  Probably inefficient.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">containsWith</span><span class="hljs-params">(pred, x, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                <span class="hljs-keyword">if</span> (pred(x, list[idx])) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        R.containsWith = curry3(containsWith);

        <span class="hljs-comment">/**
         * Returns a new list containing only one copy of each element in the original list.
         * Equality is strict here, meaning reference equality for objects and non-coercing equality
         * for primitives.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} list The array to consider.
         * @return {Array} The list of unique items.
         * @example
         *
         * uniq([1, 1, 2, 1]); //= [1, 2]
         * uniq([{}, {}]);     //= [{}, {}]
         * uniq([1, "1"]);     //= [1, "1"]
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Returns a new list containing only one copy of each element in the original list.
Equality is strict here, meaning reference equality for objects and non-coercing equality
for primitives.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> uniq = R.uniq = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniq</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">var</span> result = [], item;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                item = list[idx];
                <span class="hljs-keyword">if</span> (!contains(item, result)) {
                    result.push(item);
                }
            }
            <span class="hljs-keyword">return</span> result;
        };

        <span class="hljs-comment">/**
         * Returns `true` if all elements are unique, otherwise `false`.
         * Uniquness is determined using strict equality (`===`).
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} list The array to consider.
         * @return {boolean} `true` if all elements are unique, else `false`.
         * @example
         *
         * isSet(["1", 1]); //= true
         * isSet([1, 1]);   //= false
         * isSet([{}, {}]); //= true
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>returns <code>true</code> if all of the elements in the <code>list</code> are unique.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.isSet = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isSet</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">var</span> len = list.length;
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++i &lt; len) {
                <span class="hljs-keyword">if</span> (indexOf(list, list[i], i+<span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        };

        <span class="hljs-comment">/**
         * Returns a new list containing only one copy of each element in the original list, based
         * upon the value returned by applying the supplied predicate to two list elements. Prefers
         * the first item if two items compare equal based on the predicate.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} list The array to consider.
         * @return {Array} The list of unique items.
         * @example
         *
         * var strEq = function(a, b) { return ("" + a) === ("" + b) };
         * uniqWith(strEq)([1, "1", 2, 1]); //= [1, 2]
         * uniqWith(strEq)([{}, {}]);       //= [{}]
         * uniqWith(strEq)([1, "1", 1]);    //= [1]
         * uniqWith(strEq)(["1", 1, 1]);    //= ["1"]
         */</span>
        <span class="hljs-keyword">var</span> uniqWith = R.uniqWith = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_uniqWith</span><span class="hljs-params">(pred, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">var</span> result = [], item;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                item = list[idx];
                <span class="hljs-keyword">if</span> (!containsWith(pred, item, result)) {
                    result.push(item);
                }
            }
            <span class="hljs-keyword">return</span> result;
        });


        <span class="hljs-comment">/**
         * Returns a new list by plucking the same named property off all objects in the list supplied.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {string|number} key The key name to pluck off of each object.
         * @param {Array} list The array to consider.
         * @return {Array} The list of values for the given key.
         * @example
         *
         * pluck("a")([{a: 1}, {a: 2}]); //= [1, 2]
         * pluck(0)([[1, 2], [3, 4]]);   //= [1, 3]
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Returns a new list by plucking the same named property off all objects in the list supplied.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> pluck = R.pluck = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_pluck</span><span class="hljs-params">(p, list)</span> </span>{
            <span class="hljs-keyword">return</span> map(prop(p), list);
        });

        <span class="hljs-comment">/**
         * `makeFlat` is a helper function that returns a one-level or fully recursive function
         * based on the flag passed in.
         *
         * @private
         *
         */</span>
        <span class="hljs-keyword">var</span> makeFlat = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_makeFlat</span><span class="hljs-params">(recursive)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__flatt</span><span class="hljs-params">(list)</span> </span>{
                <span class="hljs-keyword">var</span> array, value, result = [], val, i = -<span class="hljs-number">1</span>, j, ilen = list.length, jlen;
                <span class="hljs-keyword">while</span> (++i &lt; ilen) {
                    array = list[i];
                    <span class="hljs-keyword">if</span> (isArrayLike(array)) {
                        value = (recursive) ? __flatt(array) : array;
                        j = -<span class="hljs-number">1</span>;
                        jlen = value.length;
                        <span class="hljs-keyword">while</span> (++j &lt; jlen) {
                            result.push(value[j]);
                        }
                    } <span class="hljs-keyword">else</span> {
                        result.push(array);
                    }
                }
                <span class="hljs-keyword">return</span> result;
            };
        };

        <span class="hljs-comment">/**
         * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting
         * them in a new array, depth-first.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} list The array to consider.
         * @return {Array} The flattened list.
         * @example
         *
         * flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
         * //= [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Returns a list that contains a flattened version of the supplied list.  For example:</p>
<pre><code>flatten([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>, [<span class="hljs-number">6</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, [<span class="hljs-number">9</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>], <span class="hljs-number">12</span>]]]]);
<span class="hljs-comment">// =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> flatten = R.flatten = makeFlat(<span class="hljs-literal">true</span>);
        aliasFor(<span class="hljs-string">'flatten'</span>).is(<span class="hljs-string">'flattenDeep'</span>);

        <span class="hljs-comment">/**
         * Returns a new list by pulling every item at the first level of nesting out, and putting
         * them in a new array.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} list The array to consider.
         * @return {Array} The flattened list.
         * @example
         *
         * flat([1, [2], [[3]]]);
         * //= [1, 2, [3]]
         * flat([[1, 2], [3, 4], [5, 6]]);
         * //= [1, 2, 3, 4, 5, 6]
         */</span>
        <span class="hljs-keyword">var</span> unnest = R.unnest = makeFlat(<span class="hljs-literal">false</span>);
        aliasFor(<span class="hljs-string">'unnest'</span>).is(<span class="hljs-string">'flattenShallow'</span>);

        <span class="hljs-comment">/**
         * Creates a new list out of the two supplied by applying the function to each
         * equally-positioned pair in the lists.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function used to combine the two elements into one value.
         * @param {Array} list1 The first array to consider.
         * @param {Array} list2 The second array to consider.
         * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
         * using `fn`.
         * @example
         *
         * zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
         * //= [f(1, 'a'), f(2, 'b'), f(3, 'c')]
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Creates a new list out of the two supplied by applying the function to each
equally-positioned pair in the lists.  For example,</p>
<pre><code>zipWith(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);
<span class="hljs-comment">//= [f(1, 'a'), f(2, 'b'), f(3, 'c')]</span>
</code></pre><p>Note that the output list will only be as long as the length of the shorter input list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.zipWith = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_zipWith</span><span class="hljs-params">(fn, a, b)</span> </span>{
            <span class="hljs-keyword">var</span> rv = [], i = -<span class="hljs-number">1</span>, len = <span class="hljs-built_in">Math</span>.min(a.length, b.length);
            <span class="hljs-keyword">while</span> (++i &lt; len) {
                rv[i] = fn(a[i], b[i]);
            }
            <span class="hljs-keyword">return</span> rv;
        });

        <span class="hljs-comment">/**
         * Creates a new list out of the two supplied by pairing up equally-positioned items from
         * both lists. Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} list1 The first array to consider.
         * @param {Array} list2 The second array to consider.
         * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
         * @example
         *
         * zip([1, 2, 3], ['a', 'b', 'c']);
         * //= [[1, 'a'], [2, 'b'], [3, 'c']]
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Creates a new list out of the two supplied by yielding the pair of each
equally-positioned pair in the lists.  For example,</p>
<pre><code>zip([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);
<span class="hljs-comment">//= [[1, 'a'], [2, 'b'], [3, 'c']]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.zip = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_zip</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">var</span> rv = [];
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.min(a.length, b.length);
            <span class="hljs-keyword">while</span> (++i &lt; len) {
                rv[i] = [a[i], b[i]];
            }
            <span class="hljs-keyword">return</span> rv;
        });

        <span class="hljs-comment">/**
         * Creates a new object out of a list of keys and a list of values.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} keys The array that will be properties on the output object.
         * @param {Array} values The list of values on the output object.
         * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
         * @example
         *
         * zipObj(['a', 'b', 'c'], [1, 2, 3]);
         * //= {a: 1, b: 2, c: 3}
         */</span>
        R.zipObj = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_zipObj</span><span class="hljs-params">(keys, values)</span> </span>{
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>, len = keys.length, out = {};
            <span class="hljs-keyword">while</span> (++i &lt; len) {
                out[keys[i]] = values[i];
            }
            <span class="hljs-keyword">return</span> out;
        });

        <span class="hljs-comment">/**
         * Creates a new object out of a list key-value pairs.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} An array of two-element arrays that will be the keys and values of the ouput object.
         * @return {Object} The object made by pairing up `keys` and `values`.
         * @example
         *
         * fromPairs([['a', 1], ['b', 2],  ['c', 3]]);
         * //= {a: 1, b: 2, c: 3}
         */</span>
        R.fromPairs = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fromPairs</span><span class="hljs-params">(pairs)</span> </span>{
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>, len = pairs.length, out = {};
            <span class="hljs-keyword">while</span> (++i &lt; len) {
                <span class="hljs-keyword">if</span> (isArray(pairs[i]) &amp;&amp; pairs[i].length) {
                    out[pairs[i][<span class="hljs-number">0</span>]] = pairs[i][<span class="hljs-number">1</span>];
                }
            }
            <span class="hljs-keyword">return</span> out;
        };


        <span class="hljs-comment">/**
         * Creates a new list out of the two supplied by applying the function
         * to each possible pair in the lists.
         *
         * @see xprod
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function to join pairs with.
         * @param {Array} as The first list.
         * @param {Array} bs The second list.
         * @return {Array} The list made by combining each possible pair from
         * `as` and `bs` using `fn`.
         * @example
         *
         * xProdWith(f, [1, 2], ['a', 'b'])
         * //= [f(1, 'a'), f(1, 'b'), f(2, 'a'), f(2, 'b')];
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Creates a new list out of the two supplied by applying the function
to each possible pair in the lists.  For example,</p>
<pre><code>xProdWith(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])
<span class="hljs-comment">//= [f(1, 'a'), f(1, 'b'), f(2, 'a'), f(2, 'b')];</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.xprodWith = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_xprodWith</span><span class="hljs-params">(fn, a, b)</span> </span>{
            <span class="hljs-keyword">if</span> (isEmpty(a) || isEmpty(b)) {
                <span class="hljs-keyword">return</span> [];
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Better to push them all or to do <code>new Array(ilen * jlen)</code> and
calculate indices?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>, ilen = a.length, j, jlen = b.length, result = [];
            <span class="hljs-keyword">while</span> (++i &lt; ilen) {
                j = -<span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (++j &lt; jlen) {
                    result.push(fn(a[i], b[j]));
                }
            }
            <span class="hljs-keyword">return</span> result;
        });

        <span class="hljs-comment">/**
         * Creates a new list out of the two supplied by creating each possible
         * pair from the lists.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} as The first list.
         * @param {Array} bs The second list.
         * @return {Array} The list made by combining each possible pair from
         * `as` and `bs` into pairs (`[a, b]`).
         * @example
         *
         * xProdWith(f, [1, 2], ['a', 'b'])
         * //= [f(1, 'a'), f(1, 'b'), f(2, 'a'), f(2, 'b')];
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Creates a new list out of the two supplied by yielding the pair of
each possible pair in the lists.  For example,</p>
<pre><code>xProd([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
<span class="hljs-comment">//= [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.xprod = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_xprod</span><span class="hljs-params">(a, b)</span> </span>{ <span class="hljs-comment">// = xprodWith(prepend); (takes about 3 times as long...)</span>
            <span class="hljs-keyword">if</span> (isEmpty(a) || isEmpty(b)) {
                <span class="hljs-keyword">return</span> [];
            }
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> ilen = a.length;
            <span class="hljs-keyword">var</span> j;
            <span class="hljs-keyword">var</span> jlen = b.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Better to push them all or to do <code>new Array(ilen * jlen)</code> and calculate indices?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> result = [];
            <span class="hljs-keyword">while</span> (++i &lt; ilen) {
                j = -<span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (++j &lt; jlen) {
                    result.push([a[i], b[j]]);
                }
            }
            <span class="hljs-keyword">return</span> result;
        });

        <span class="hljs-comment">/**
         * Returns a new list with the same elements as the original list, just
         * in the reverse order.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} list The list to reverse.
         * @return {Array} A copy of the list in reverse order.
         * @example
         *
         * reverse([1, 2, 3]);  //= [3, 2, 1]
         * reverse([1, 2]);     //= [2, 1]
         * reverse([1]);        //= [1]
         * reverse([]);         //= []
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Returns a new list with the same elements as the original list, just
in the reverse order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.reverse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_reverse</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">return</span> clone(list || []).reverse();
        };

        <span class="hljs-comment">/**
         * Returns a list of numbers from `from` (inclusive) to `to`
         * (exclusive). In mathematical terms, `range(a, b)` is equivalent to
         * the half-open interval `[a, b)`.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {number} from The first number in the list.
         * @param {number} to One more than the last number in the list.
         * @return {Array} The list of numbers in tthe set `[a, b)`.
         * @example
         *
         * range(1, 5);     //= [1, 2, 3, 4]
         * range(50, 53);   //= [50, 51, 52]
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Returns a list of numbers from <code>from</code> (inclusive) to <code>to</code> (exclusive).
For example,</p>
<pre><code>range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// =&gt; [1, 2, 3, 4]</span>
range(<span class="hljs-number">50</span>, <span class="hljs-number">53</span>) <span class="hljs-comment">// =&gt; [50, 51, 52]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.range = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_range</span><span class="hljs-params">(from, to)</span> </span>{
            <span class="hljs-keyword">if</span> (from &gt;= to) {
                <span class="hljs-keyword">return</span> [];
            }
            <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>, result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">Math</span>.floor(to) - <span class="hljs-built_in">Math</span>.ceil(from));
            <span class="hljs-keyword">for</span> (; from &lt; to; idx++, from++) {
                result[idx] = from;
            }
            <span class="hljs-keyword">return</span> result;
        });

        <span class="hljs-comment">/**
         * Returns a string made by inserting the `separator` between each
         * element and concatenating all the elements into a single string.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {string|number} separator The string used to separate the elements.
         * @param {Array} xs The elements to join into a string.
         * @return {string} The string made by concatenating `xs` with `separator`.
         * @example
         *
         * var spacer = join(" ");
         * spacer(["a", 2, 3.4]);   //= "a 2 3.4"
         * join("|", [1, 2, 3]);    //= "1|2|3"
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Returns the elements of the list as a string joined by a separator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.join = invoker(<span class="hljs-string">"join"</span>, <span class="hljs-built_in">Array</span>.prototype);

        <span class="hljs-comment">/**
         * Returns the elements from `xs` starting at `a` and ending at `b - 1`.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {number} a The starting index.
         * @param {number} b One more than the ending index.
         * @param {Array} xs The list to take elements from.
         * @return {Array} The items from `a` to `b - 1` from `xs`.
         * @example
         *
         * var xs = range(0, 10);
         * slice(2, 5)(xs); //= [2, 3, 4]
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Returns the sublist of a list starting with the first index and
ending before the second one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.slice = invoker(<span class="hljs-string">"slice"</span>, <span class="hljs-built_in">Array</span>.prototype);
        <span class="hljs-comment">/**
         * Returns the elements from `xs` starting at `a` going to the end of `xs`.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {number} a The starting index.
         * @param {Array} xs The list to take elements from.
         * @return {Array} The items from `a` to the end of `xs`.
         * @example
         *
         * var xs = range(0, 10);
         * slice.from(2)(xs); //= [2, 3, 4, 5, 6, 7, 8, 9]
         *
         * var ys = range(4, 8);
         * var tail = slice.from(1);
         * tail(xs); //= [5, 6, 7]
         */</span>
        R.slice.from = flip(R.slice)(<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Removes the sub-list of <code>list</code> starting at index <code>start</code> and containing
<code>count</code> elements.  <em>Note that this is not destructive</em>: it returns a
copy of the list with the changes.
<small>No lists have been harmed in the application of this function.</small></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.remove = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_remove</span><span class="hljs-params">(start, count, list)</span> </span>{
            <span class="hljs-keyword">return</span> concat(_slice(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(start, list.length)), _slice(list, <span class="hljs-built_in">Math</span>.min(list.length, start + count)));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Inserts the supplied element into the list, at index <code>index</code>.  <em>Note
that this is not destructive</em>: it returns a copy of the list with the changes.
<small>No lists have been harmed in the application of this function.</small></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.insert = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_insert</span><span class="hljs-params">(index, elt, list)</span> </span>{
            index = index &lt; list.length &amp;&amp; index &gt;= <span class="hljs-number">0</span> ? index : list.length;
            <span class="hljs-keyword">return</span> concat(append(elt, _slice(list, <span class="hljs-number">0</span>, index)), _slice(list, index));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Inserts the sub-list into the list, at index <code>index</code>.  <em>Note  that this
is not destructive</em>: it returns a copy of the list with the changes.
<small>No lists have been harmed in the application of this function.</small></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.insert.all = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_insertAll</span><span class="hljs-params">(index, elts, list)</span> </span>{
            index = index &lt; list.length &amp;&amp; index &gt;= <span class="hljs-number">0</span> ? index : list.length;
            <span class="hljs-keyword">return</span> concat(concat(_slice(list, <span class="hljs-number">0</span>, index), elts), _slice(list, index));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Makes a comparator function out of a function that reports whether the first element is less than the second.</p>
<pre><code><span class="hljs-keyword">var</span> cmp = comparator(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
    <span class="hljs-keyword">return</span> a.age &lt; b.age;
};
sort(cmp, people);
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> comparator = R.comparator = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_comparator</span><span class="hljs-params">(pred)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{
                <span class="hljs-keyword">return</span> pred(a, b) ? -<span class="hljs-number">1</span> : pred(b, a) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
            };
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Returns a copy of the list, sorted according to the comparator function, which should accept two values at a
time and return a negative number if the first value is smaller, a positive number if it’s larger, and zero
if they are equal.  Please note that this is a <strong>copy</strong> of the list.  It does not modify the original.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> sort = R.sort = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span><span class="hljs-params">(comparator, list)</span> </span>{
            <span class="hljs-keyword">return</span> clone(list).sort(comparator);
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Splits a list into sublists stored in an object, based on the result of calling a String-returning function
on each element, and grouping the results according to values returned.</p>
<pre><code><span class="hljs-keyword">var</span> byGrade = groupBy(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(student)</span> </span>{
    <span class="hljs-keyword">var</span> score = student.score
    <span class="hljs-keyword">return</span> (score &lt; <span class="hljs-number">65</span>) ? <span class="hljs-string">'F'</span> : (score &lt; <span class="hljs-number">70</span>) ? <span class="hljs-string">'D'</span> :
           (score &lt; <span class="hljs-number">80</span>) ? <span class="hljs-string">'C'</span> : (score &lt; <span class="hljs-number">90</span>) ? <span class="hljs-string">'B'</span> : <span class="hljs-string">'A'</span>;
};
<span class="hljs-keyword">var</span> students = [{name: <span class="hljs-string">"Abby"</span>, score: <span class="hljs-number">84</span>} <span class="hljs-comment">/*, ... */</span>,
                {name: <span class="hljs-string">'Jack'</span>, score: <span class="hljs-number">69</span>}];
byGrade(students);
<span class="hljs-comment">//=&gt; {</span>
<span class="hljs-comment">//   "A": [{name: 'Dianne', score: 99} /*, ... */],</span>
<span class="hljs-comment">//   "B": [{name: "Abby", score: 84} /*, ... */]</span>
<span class="hljs-comment">//   /*, ... */</span>
<span class="hljs-comment">//   "F": [{name: 'Eddy', score: 58}]</span>
<span class="hljs-comment">// }</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.groupBy = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_groupBy</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(acc, elt)</span> </span>{
                <span class="hljs-keyword">var</span> key = fn(elt);
                acc[key] = append(elt, acc[key] || (acc[key] = []));
                <span class="hljs-keyword">return</span> acc;
            }, {}, list);
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Takes a predicate and a list and returns the pair of lists of
elements which do and do not satisfy the predicate, respectively.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.partition = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_groupBy</span><span class="hljs-params">(pred, list)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(acc, elt)</span> </span>{
                acc[pred(elt) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>].push(elt);
                <span class="hljs-keyword">return</span> acc;
            }, [[], []], list);
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <h2 id="object-functions">Object Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>These functions operate on plain Javascript object, adding simple functions to test properties on these
objects.  Many of these are of most use in conjunction with the list functions, operating on lists of
objects.</p>

            </div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Runs the given function with the supplied object, then returns the object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.tap = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_tap</span><span class="hljs-params">(x, fn)</span> </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">"function"</span>) { fn(x); }
            <span class="hljs-keyword">return</span> x;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Tests if two items are equal.  Equality is strict here, meaning reference equality for objects and
non-coercing equality for primitives.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.eq = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_eq</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_eq</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a === b; } : a === b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Returns a function that when supplied an object returns the indicated property of that object, if it exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> prop = R.prop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_prop</span><span class="hljs-params">(p, obj)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_prop</span><span class="hljs-params">(obj)</span> </span>{ <span class="hljs-keyword">return</span> obj[p]; } :  obj[p];
        };
        aliasFor(<span class="hljs-string">"prop"</span>).is(<span class="hljs-string">"nth"</span>).and(<span class="hljs-string">"get"</span>); <span class="hljs-comment">// TODO: are we sure?  Matches some other libs, but might want to reserve for other use.</span>


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>Returns a function that when supplied an object returns the result of running the indicated function on
that object, if it has such a function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.func = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">(fn, obj)</span> </span>{
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_func</span><span class="hljs-params">(obj)</span> </span>{
                <span class="hljs-keyword">return</span> obj[fn].apply(obj, _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _func : _func(obj);
        };


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Returns a function that when supplied a property name returns that property on the indicated object, if it
exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.props = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_props</span><span class="hljs-params">(obj, prop)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_props</span><span class="hljs-params">(prop)</span> </span>{ <span class="hljs-keyword">return</span> obj &amp;&amp; obj[prop]; } : obj &amp;&amp; obj[prop];
        };


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Returns a function that always returns the given value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> always = R.always = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_always</span><span class="hljs-params">(val)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> val;
            };
        };
        aliasFor(<span class="hljs-string">"always"</span>).is(<span class="hljs-string">"constant"</span>).and(<span class="hljs-string">"K"</span>);


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        <span class="hljs-keyword">var</span> anyBlanks = R.any(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_any</span><span class="hljs-params">(val)</span> </span>{
            <span class="hljs-keyword">return</span> val == <span class="hljs-literal">null</span>;
        });

        <span class="hljs-keyword">var</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
        <span class="hljs-keyword">var</span> nativeKeys = <span class="hljs-built_in">Object</span>.keys;

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Returns a list containing the names of all the enumerable own
properties of the supplied object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> keys = R.keys = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_keys</span><span class="hljs-params">(obj)</span> </span>{
            <span class="hljs-keyword">if</span> (nativeKeys) <span class="hljs-keyword">return</span> nativeKeys(<span class="hljs-built_in">Object</span>(obj));
            <span class="hljs-keyword">var</span> prop, ks = [];
            <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> obj) {
                <span class="hljs-keyword">if</span> (hasOwnProperty.call(obj, prop)) {
                    ks.push(prop);
                }
            }
            <span class="hljs-keyword">return</span> ks;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Returns a list containing the names of all the
properties of the supplied object, including prototype properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.keysIn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_keysIn</span><span class="hljs-params">(obj)</span> </span>{
            <span class="hljs-keyword">var</span> prop, ks = [];
            <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> obj) {
                ks.push(prop);
            }
            <span class="hljs-keyword">return</span> ks;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Returns a list of all the enumerable own properties of the supplied object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.values = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_values</span><span class="hljs-params">(obj)</span> </span>{
            <span class="hljs-keyword">var</span> prop, props = keys(obj),
                length = props.length,
                vals = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(length);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                vals[i] = obj[props[i]];
            }
            <span class="hljs-keyword">return</span> vals;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Returns a list of all the properties, including prototype properties,
of the supplied object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.valuesIn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_valuesIn</span><span class="hljs-params">(obj)</span> </span>{
            <span class="hljs-keyword">var</span> prop, vs = [];
            <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> obj) {
                vs.push(obj[prop]);
            }
            <span class="hljs-keyword">return</span> vs;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>internal helper function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickWith</span><span class="hljs-params">(test, obj)</span> </span>{
            <span class="hljs-keyword">var</span> copy = {},
                props = keys(obj), prop, val;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = props.length; i &lt; len; i++) {
                prop = props[i];
                val = obj[prop];
                <span class="hljs-keyword">if</span> (test(val, prop, obj)) {
                    copy[prop] = val;
                }
            }
            <span class="hljs-keyword">return</span> copy;
        }

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the
property is ignored</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.pick = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pick</span><span class="hljs-params">(names, obj)</span> </span>{
            <span class="hljs-keyword">return</span> pickWith(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val, key)</span> </span>{
                <span class="hljs-keyword">return</span> contains(key, names);
            }, obj);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Returns a partial copy of an object omitting the keys specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.omit = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">omit</span><span class="hljs-params">(names, obj)</span> </span>{
            <span class="hljs-keyword">return</span> pickWith(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val, key)</span> </span>{
                <span class="hljs-keyword">return</span> !contains(key, names);
            }, obj);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.pickWith = curry2(pickWith);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Similar to <code>pick</code> except that this one includes a <code>key: undefined</code> pair for properties that don’t exist.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> pickAll = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_pickAll</span><span class="hljs-params">(names, obj)</span> </span>{
            <span class="hljs-keyword">var</span> copy = {};
            each(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> </span>{
                copy[name] = obj[name];
            }, names);
            <span class="hljs-keyword">return</span> copy;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.pickAll = curry2(pickAll);


        <span class="hljs-comment">/**
         * Assigns own enumerable properties of the other object to the destination
         * object prefering items in other.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} other The other object to merge with destination.
         * @returns {Object} Returns the destination object.
         *
         * @example
         * extend({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
         * // =&gt; { 'name': 'fred', 'age': 40 }
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span><span class="hljs-params">(destination, other)</span> </span>{
            <span class="hljs-keyword">var</span> props = keys(other),
                i = -<span class="hljs-number">1</span>, length = props.length;
            <span class="hljs-keyword">while</span> (++i &lt; length) {
                destination[props[i]] = other[props[i]];
            }
            <span class="hljs-keyword">return</span> destination;
        }

        <span class="hljs-comment">/**
         * Create a new object with the own properties of a
         * merged with the own properties of object b.
         *
         * @static
         * @memberOf R
         * @category Object
         * @param {Object} a source object
         * @param {Object} b object with higher precendence in output
         * @returns {Object} Returns the destination object.
         *
         * @example
         * mixin({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
         * // =&gt; { 'name': 'fred', 'age': 40 }
         */</span>
        R.mixin = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_mixin</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> extend(extend({}, a), b);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Reports whether two functions have the same value for the specified property.  Useful as a curried predicate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.eqProps = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eqProps</span><span class="hljs-params">(prop, obj1, obj2)</span> </span>{
            <span class="hljs-keyword">return</span> obj1[prop] === obj2[prop];
        });


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>internal helper for <code>where</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">satisfiesSpec</span><span class="hljs-params">(spec, parsedSpec, testObj)</span> </span>{
            <span class="hljs-keyword">if</span> (spec === testObj) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
            <span class="hljs-keyword">if</span> (testObj == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
            parsedSpec.fn = parsedSpec.fn || [];
            parsedSpec.obj = parsedSpec.obj || [];
            <span class="hljs-keyword">var</span> key, val, i = -<span class="hljs-number">1</span>, fnLen = parsedSpec.fn.length, j = -<span class="hljs-number">1</span>, objLen = parsedSpec.obj.length;
            <span class="hljs-keyword">while</span> (++i &lt; fnLen) {
                key = parsedSpec.fn[i];
                val = spec[key];</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>if (!hasOwnProperty.call(testObj, key)) {
   return false;
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> testObj)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">if</span> (!val(testObj[key], testObj)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-keyword">while</span> (++j &lt; objLen) {
                key = parsedSpec.obj[j];
                <span class="hljs-keyword">if</span> (spec[key] !== testObj[key]) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p><code>where</code> takes a spec object and a test object and returns true if the test satisfies the spec.
Any property on the spec that is not a function is interpreted as an equality
relation. For example:</p>
<pre><code><span class="hljs-keyword">var</span> spec = {x: <span class="hljs-number">2</span>};
where(spec, {w: <span class="hljs-number">10</span>, x: <span class="hljs-number">2</span>, y: <span class="hljs-number">300</span>}); <span class="hljs-comment">// =&gt; true, x === 2</span>
where(spec, {x: <span class="hljs-number">1</span>, y: <span class="hljs-string">'moo'</span>, z: <span class="hljs-literal">true</span>}); <span class="hljs-comment">// =&gt; false, x !== 2</span>
</code></pre><p>If the spec has a property mapped to a function, then <code>where</code> evaluates the function, passing in
the test object’s value for the property in question, as well as the whole test object. For example:</p>
<pre><code><span class="hljs-keyword">var</span> spec = {x: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val, obj)</span> </span>{ <span class="hljs-keyword">return</span>  val + obj.y &gt; <span class="hljs-number">10</span>; };
where(spec, {x: <span class="hljs-number">2</span>, y: <span class="hljs-number">7</span>}); <span class="hljs-comment">// =&gt; false</span>
where(spec, {x: <span class="hljs-number">3</span>, y: <span class="hljs-number">8</span>}); <span class="hljs-comment">// =&gt; true</span>
</code></pre><p><code>where</code> is well suited to declarativley expressing constraints for other functions, e.g., <code>filter</code>:</p>
<pre><code><span class="hljs-keyword">var</span> xs = [{x: <span class="hljs-number">2</span>, y: <span class="hljs-number">1</span>}, {x: <span class="hljs-number">10</span>, y: <span class="hljs-number">2</span>},
          {x: <span class="hljs-number">8</span>, y: <span class="hljs-number">3</span>}, {x: <span class="hljs-number">10</span>, y: <span class="hljs-number">4</span>}];
<span class="hljs-keyword">var</span> fxs = filter(where({x: <span class="hljs-number">10</span>}), xs);
<span class="hljs-comment">// fxs ==&gt; [{x: 10, y: 2}, {x: 10, y: 4}]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.where = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">where</span><span class="hljs-params">(spec, testObj)</span> </span>{
            <span class="hljs-keyword">var</span> parsedSpec = R.groupBy(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> spec[key] === <span class="hljs-string">"function"</span> ? <span class="hljs-string">"fn"</span> : <span class="hljs-string">"obj"</span>;
                }, keys(spec)
            );
            <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">throw</span> NO_ARGS_EXCEPTION;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(testObj)</span> </span>{
                        <span class="hljs-keyword">return</span> satisfiesSpec(spec, parsedSpec, testObj);
                    };
            }
            <span class="hljs-keyword">return</span> satisfiesSpec(spec, parsedSpec, testObj);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <h2 id="miscellaneous-functions">Miscellaneous Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>A few functions in need of a good home.</p>

            </div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>Expose the functions from ramda as properties on another object.  If the passed-in object is the
global object, or the passed-in object is “falsy”, then the ramda functions become global functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.installTo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span> </span>{
            <span class="hljs-keyword">return</span> extend(obj || global, R);
        };

        R.is = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is</span><span class="hljs-params">(ctor, val)</span> </span>{
            <span class="hljs-keyword">return</span> val != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">Object</span>(val) <span class="hljs-keyword">instanceof</span> ctor;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>A function that always returns <code>0</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.alwaysZero = always(<span class="hljs-number">0</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>A function that always returns <code>false</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.alwaysFalse = always(<span class="hljs-literal">false</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>A function that always returns <code>true</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.alwaysTrue = always(<span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <h2 id="logic-functions">Logic Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>These functions are very simple wrappers around the built-in logical operators, useful in building up
more complex functional forms.</p>

            </div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>A function wrapping calls to the two functions in an <code>&amp;&amp;</code> operation, returning <code>true</code> or <code>false</code>.  Note that
this is short-circuited, meaning that the second function will not be invoked if the first returns a false-y
value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.and = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">and</span><span class="hljs-params">(f, g)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_and</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> !!(f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) &amp;&amp; g.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
            };
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>A function wrapping calls to the two functions in an <code>||</code> operation, returning <code>true</code> or <code>false</code>.  Note that
this is short-circuited, meaning that the second function will not be invoked if the first returns a truth-y
value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.or = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">or</span><span class="hljs-params">(f, g)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_or</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> !!(f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || g.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
            };
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>A function wrapping a call to the given function in a <code>!</code> operation.  It will return <code>true</code> when the
underlying function would return a false-y value, and <code>false</code> when it would return a truth-y one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> not = R.not = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_not</span><span class="hljs-params">(f)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> !f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);};
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Create a predicate wrapper which will call a pick function (all/any) for each predicate</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> predicateWrap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_predicateWrap</span><span class="hljs-params">(predPicker)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(preds <span class="hljs-comment">/* , args */</span>)</span> </span>{
                <span class="hljs-keyword">var</span> predIterator = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
                    <span class="hljs-keyword">return</span> predPicker(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(predicate)</span> </span>{
                        <span class="hljs-keyword">return</span> predicate.apply(<span class="hljs-literal">null</span>, args);
                    }, preds);
                };
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span> ?</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Call function imediately if given arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        predIterator.apply(<span class="hljs-literal">null</span>, _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)) :</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Return a function which will call the predicates with the provided arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        arity(max(pluck(<span class="hljs-string">"length"</span>, preds)), predIterator);
            };
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>Given a list of predicates returns a new predicate that will be true exactly when all of them are.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.allPredicates = predicateWrap(all);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Given a list of predicates returns a new predicate that will be true exactly when any one of them is.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.anyPredicates = predicateWrap(any);</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <h2 id="arithmetic-functions">Arithmetic Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>These functions wrap up the certain core arithmetic operators</p>

            </div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * Adds two numbers (or strings). Equivalent to `a + b` but curried.
         *
         * @static
         * @memberOf R
         * @param {number|string} a The first value.
         * @param {number|string} b The second value.
         * @return {number|string} The result of `a + b`.
         * @example
         *
         * var increment = add(1);
         * increment(10);   //= 11
         * add(2, 3);       //=  5
         * add(7)(10);      //= 17
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Adds two numbers (or strings). Equivalent to <code>a + b</code> but curried.</p>
<pre><code><span class="hljs-keyword">var</span> increment = add(<span class="hljs-number">1</span>);
increment(<span class="hljs-number">10</span>);   <span class="hljs-comment">//= 11</span>
add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);       <span class="hljs-comment">//=  5</span>
add(<span class="hljs-number">7</span>)(<span class="hljs-number">10</span>);      <span class="hljs-comment">//= 17</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> add = R.add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_add</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a + b; } :  a + b;
        };

        <span class="hljs-comment">/**
         * Multiplies two numbers. Equivalent to `a * b` but curried.
         *
         * @static
         * @memberOf R
         * @param {number} a The first value.
         * @param {number} b The second value.
         * @return {number} The result of `a * b`.
         * @example
         *
         * var double = multiply(2);
         * var triple = multiply(3);
         * double(3);       //=  6
         * triple(4);       //= 12
         * multiply(2, 5);  //= 10
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>Multiplies two numbers. Equivalent to <code>a * b</code> but curried.</p>
<pre><code><span class="hljs-keyword">var</span> double = multiply(<span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> triple = multiply(<span class="hljs-number">3</span>);
double(<span class="hljs-number">3</span>);       <span class="hljs-comment">//=  6</span>
triple(<span class="hljs-number">4</span>);       <span class="hljs-comment">//= 12</span>
multiply(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">//= 10</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> multiply = R.multiply = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_multiply</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a * b; } :  a * b;
        };

        <span class="hljs-comment">/**
         * Subtracts two numbers. Equivalent to `a - b` but curried.
         *
         * @static
         * @memberOf R
         * @see subtractN
         * @param {number} a The first value.
         * @param {number} b The second value.
         * @return {number} The result of `a - b`.
         * @example
         *
         * var complementaryAngle = subtract(90);
         * complementaryAngle(30); //= 60
         *
         * var theRestOf = subtract(1);
         * theRestOf(0.25); //= 0.75
         *
         * subtract(10)(8); //= 2
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>Subtracts the second parameter from the first.  This is
automatically curried, and while at times the curried version might
be useful, often the curried version of <code>subtractN</code> might be what’s
wanted.</p>
<pre><code><span class="hljs-keyword">var</span> complementaryAngle = subtract(<span class="hljs-number">90</span>);
complementaryAngle(<span class="hljs-number">30</span>); <span class="hljs-comment">//= 60</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> subtract = R.subtract = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_subtract</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a - b; } :  a - b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        <span class="hljs-comment">/**
         * Subtracts two numbers in reverse order. Equivalent to `b - a` but
         * curried. Probably more useful when partially applied than
         * `subtract`.
         *
         * @static
         * @memberOf R
         * @param {number} a The first value.
         * @param {number} b The second value.
         * @return {number} The result of `a - b`.
         * @example
         *
         * var complementaryAngle = subtract(90);
         * complementaryAngle(30); //= 60
         *
         * var theRestOf = subtract(1);
         * theRestOf(0.25); //= 0.75
         *
         * subtract(10)(8); //= 2
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Reversed version of <code>subtract</code>, where first parameter is subtracted
from the second.  The curried version of this one might me more
useful than that of <code>subtract</code>.  For instance:</p>
<pre><code><span class="hljs-keyword">var</span> decrement = subtractN(<span class="hljs-number">1</span>);
decrement(<span class="hljs-number">10</span>);   <span class="hljs-comment">//= 9;</span>
subtractN(<span class="hljs-number">2</span>)(<span class="hljs-number">5</span>); <span class="hljs-comment">//= 3</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.subtractN = flip(subtract);

        <span class="hljs-comment">/**
         * Divides two numbers. Equivalent to `a / b`.
         *
         * @static
         * @memberOf R
         * @see divideBy
         * @param {number} a The first value.
         * @param {number} b The second value.
         * @return {number} The result of `a / b`.
         * @example
         *
         * var reciprocal = divide(1);
         * reciprocal(4);   //= 0.25
         * divide(71, 100); //= 0.71
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Divides the first parameter by the second.  This is automatically
curried, and while at times the curried
version might be useful, often the curried version of <code>divideBy</code> might be what’s wanted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> divide = R.divide = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_divide</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a / b; } :  a / b;
        };

        <span class="hljs-comment">/**
         * Divides two numbers in reverse order. Equivalent to `b / a`.
         *
         * @static
         * @memberOf R
         * @param {number} a The second value.
         * @param {number} b The first value.
         * @return {number} The result of `b / a`.
         * @example
         *
         * var half = divideBy(2);
         * half(42); // =&gt; 21
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>Reversed version of <code>divide</code>, where the second parameter is divided by the first.  The curried version of
this one might be more useful than that of <code>divide</code>.  For instance:</p>
<pre><code><span class="hljs-keyword">var</span> half = divideBy(<span class="hljs-number">2</span>);
half(<span class="hljs-number">42</span>); <span class="hljs-comment">// =&gt; 21</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.divideBy = flip(divide);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Divides the second parameter by the first and returns the remainder.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> modulo = R.modulo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_modulo</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a % b; } :  a % b;
        };


        <span class="hljs-comment">/**
         * Determine if the passed argument is an integer.
         *
         * @private
         * @param n
         * @return {Boolean}
         */</span>
        <span class="hljs-keyword">var</span> isInteger = <span class="hljs-built_in">Number</span>.isInteger || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInteger</span><span class="hljs-params">(n)</span> </span>{
            <span class="hljs-keyword">return</span> (n &lt;&lt; <span class="hljs-number">0</span>) === n;
        };

        <span class="hljs-comment">/**
         * mathMod behaves like the modulo operator should mathematically, unlike the `%`
         * operator (and by extension, ramda.modulo). So while "-17 % 5" is -2,
         * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
         * when the modulus is zero or negative.
         *
         * @static
         * @memberOf R
         * @param {number} m The dividend.
         * @param {number} p the modulus.
         * @return {number} The result of `b mod a`.
         * @example
         *
         * mathMod(-17, 5)  // 3
         * mathMod(17, 5)   // 2
         * mathMod(17, -5)  // NaN
         * mathMod(17, 0)   // NaN
         * mathMod(17.2, 5) // NaN
         * mathMod(17, 5.3) // NaN
         */</span>
        R.mathMod = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_mathMod</span><span class="hljs-params">(m, p)</span> </span>{
            <span class="hljs-keyword">if</span> (!isInteger(m) || m &lt; <span class="hljs-number">1</span>) { <span class="hljs-keyword">return</span> <span class="hljs-literal">NaN</span>; }
            <span class="hljs-keyword">if</span> (!isInteger(p)) { <span class="hljs-keyword">return</span> <span class="hljs-literal">NaN</span>; }
            <span class="hljs-keyword">return</span> ((m % p) + p) % p;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>Reversed version of <code>modulo</code>, where the second parameter is divided by the first.  The curried version of
this one might be more useful than that of <code>modulo</code>.  For instance:</p>
<pre><code><span class="hljs-keyword">var</span> isOdd = moduloBy(<span class="hljs-number">2</span>);
isOdd(<span class="hljs-number">42</span>); <span class="hljs-comment">// =&gt; 0</span>
isOdd(<span class="hljs-number">21</span>); <span class="hljs-comment">// =&gt; 1</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.moduloBy = flip(modulo);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Adds together all the elements of a list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.sum = foldl(add, <span class="hljs-number">0</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>Multiplies together all the elements of a list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.product = foldl(multiply, <span class="hljs-number">1</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>Returns true if the first parameter is less than the second.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.lt = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_lt</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a &lt; b; } :  a &lt; b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>Returns true if the first parameter is less than or equal to the second.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.lte = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_lte</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a &lt;= b; } :  a &lt;= b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>Returns true if the first parameter is greater than the second.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.gt = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_gt</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a &gt; b; } :  a &gt; b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>Returns true if the first parameter is greater than or equal to the second.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.gte = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_gte</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a &gt;= b; } :  a &gt;= b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>Determines the largest of a list of numbers (or elements that can be cast to numbers)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> max = R.max = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_max</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(binary(<span class="hljs-built_in">Math</span>.max), -<span class="hljs-literal">Infinity</span>, list);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>Determines the largest of a list of items as determined by pairwise comparisons from the supplied comparator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.maxWith = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_maxWith</span><span class="hljs-params">(keyFn, list)</span> </span>{
            <span class="hljs-keyword">if</span> (!(list &amp;&amp; list.length &gt; <span class="hljs-number">0</span>)) {
               <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>, winner = list[idx], max = keyFn(winner), testKey;
            <span class="hljs-keyword">while</span> (++idx &lt; list.length) {
                testKey = keyFn(list[idx]);
                <span class="hljs-keyword">if</span> (testKey &gt; max) {
                    max = testKey;
                    winner = list[idx];
                }
            }
            <span class="hljs-keyword">return</span> winner;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>TODO: combine this with maxWith?</p>

            </div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>Determines the smallest of a list of items as determined by pairwise comparisons from the supplied comparator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.minWith = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_minWith</span><span class="hljs-params">(keyFn, list)</span> </span>{
            <span class="hljs-keyword">if</span> (!(list &amp;&amp; list.length &gt; <span class="hljs-number">0</span>)) {
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>, winner = list[idx], min = keyFn(list[idx]), testKey;
            <span class="hljs-keyword">while</span> (++idx &lt; list.length) {
                testKey = keyFn(list[idx]);
                <span class="hljs-keyword">if</span> (testKey &lt; min) {
                    min = testKey;
                    winner = list[idx];
                }
            }
            <span class="hljs-keyword">return</span> winner;
        });


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>Determines the smallest of a list of numbers (or elements that can be cast to numbers)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.min = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_min</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(binary(<span class="hljs-built_in">Math</span>.min), <span class="hljs-literal">Infinity</span>, list);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <h2 id="string-functions">String Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>Much of the String.prototype API exposed as simple functions.</p>

            </div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>A substring of a String:</p>
<pre><code>substring(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"abcdefghijklm"</span>); <span class="hljs-comment">//=&gt; "cde"</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> substring = R.substring = invoker(<span class="hljs-string">"substring"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>The trailing substring of a String starting with the nth character:</p>
<pre><code>substringFrom(<span class="hljs-number">8</span>, <span class="hljs-string">"abcdefghijklm"</span>); <span class="hljs-comment">//=&gt; "ijklm"</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.substringFrom = flip(substring)(<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>The leading substring of a String ending before the nth character:</p>
<pre><code>substringTo(<span class="hljs-number">8</span>, <span class="hljs-string">"abcdefghijklm"</span>); <span class="hljs-comment">//=&gt; "abcdefgh"</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.substringTo = substring(<span class="hljs-number">0</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>The character at the nth position in a String:</p>
<pre><code>charAt(<span class="hljs-number">8</span>, <span class="hljs-string">"abcdefghijklm"</span>); <span class="hljs-comment">//=&gt; "i"</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.charAt = invoker(<span class="hljs-string">"charAt"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>The ascii code of the character at the nth position in a String:</p>
<pre><code>charCodeAt(<span class="hljs-number">8</span>, <span class="hljs-string">"abcdefghijklm"</span>); <span class="hljs-comment">//=&gt; 105</span>
<span class="hljs-comment">// (... 'a' ~ 97, 'b' ~ 98, ... 'i' ~ 105)</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.charCodeAt = invoker(<span class="hljs-string">"charCodeAt"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>Tests a regular expression agains a String</p>
<pre><code>match(<span class="hljs-regexp">/([a-z]a)/g</span>, <span class="hljs-string">"bananas"</span>); <span class="hljs-comment">//=&gt; ["ba", "na", "na"]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.match = invoker(<span class="hljs-string">"match"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>Finds the index of a substring in a string, returning -1 if it’s not present</p>
<pre><code>strIndexOf(<span class="hljs-string">'c'</span>, <span class="hljs-string">'abcdefg) //=&gt; 2</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.strIndexOf = invoker(<span class="hljs-string">"indexOf"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>Finds the last index of a substring in a string, returning -1 if it’s not present</p>
<pre><code>strLastIndexOf(<span class="hljs-string">'a'</span>, <span class="hljs-string">'banana split'</span>) <span class="hljs-comment">//=&gt; 5</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.strLastIndexOf = invoker(<span class="hljs-string">"lastIndexOf"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * The upper case version of a string.
         *
         * @static
         * @memberOf R
         * @param {string} str The string to upper case.
         * @return {string} The upper case version of `str`.
         * @example
         * toUpperCase('abc') //= 'ABC'
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>The upper case version of a string.</p>
<pre><code>toUpperCase(<span class="hljs-string">'abc'</span>) <span class="hljs-comment">//= 'ABC'</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.toUpperCase = invoker(<span class="hljs-string">"toUpperCase"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * The lower case version of a string.
         *
         * @static
         * @memberOf R
         * @param {string} str The string to lower case.
         * @return {string} The lower case version of `str`.
         * @example
         * toLowerCase('XYZ') //= 'xyz'
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>The lower case version of a string.</p>
<pre><code>toLowerCase(<span class="hljs-string">'XYZ'</span>) <span class="hljs-comment">//= 'xyz'</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.toLowerCase = invoker(<span class="hljs-string">"toLowerCase"</span>, <span class="hljs-built_in">String</span>.prototype);


        <span class="hljs-comment">/**
         * Splits a string into an array of strings based on the given
         * separator.
         *
         * @static
         * @memberOf R
         * @param {string} sep The separator string.
         * @param {string} str The string to separate into an array.
         * @return {Array} The array of strings from `str` separated by `str`.
         * @example
         *
         * var pathComponents = split('/');
         * pathComponents('/usr/local/bin/node');
         * //= ['usr', 'local', 'bin', 'node']
         *
         * split('.', 'a.b.c.xyz.d');
         * //= ['a', 'b', 'c', 'xyz', 'd']
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>Splits a string into an array of strings based on the given
separator.</p>
<pre><code><span class="hljs-keyword">var</span> pathComponents = split(<span class="hljs-string">'/'</span>);
pathComponents(<span class="hljs-string">'/usr/local/bin/node'</span>);
<span class="hljs-comment">//= ['usr', 'local', 'bin', 'node']</span>

split(<span class="hljs-string">'.'</span>, <span class="hljs-string">'a.b.c.xyz.d'</span>);
<span class="hljs-comment">//= ['a', 'b', 'c', 'xyz', 'd']</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.split = invoker(<span class="hljs-string">"split"</span>, <span class="hljs-built_in">String</span>.prototype, <span class="hljs-number">1</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>internal path function
Takes an array, paths, indicating the deep set of keys
to find. E.g.
path([‘a’, ‘b’], {a: {b: 2}}) // =&gt; 2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">path</span><span class="hljs-params">(paths, obj)</span> </span>{
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>, length = paths.length, val;
            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">return</span>; }
            val = obj;
            <span class="hljs-keyword">while</span> (val != <span class="hljs-literal">null</span> &amp;&amp; ++i &lt; length) {
                val = val[paths[i]];
            }
            <span class="hljs-keyword">return</span> val;
        }

        <span class="hljs-comment">/**
         * Retrieve a nested path on an object seperated by the specified
         * separator value.
         *
         * @static
         * @memberOf R
         * @param {string} sep The separator to use in `path`.
         * @param {string} path The path to use.
         * @return {*} The data at `path`.
         * @example
         * pathOn('/', 'a/b/c', {a: {b: {c: 3}}}) //= 3
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>Retrieve a nested path on an object seperated by the specified
separator value.</p>
<pre><code>pathOn(<span class="hljs-string">'/'</span>, <span class="hljs-string">'a/b/c'</span>, {a: {b: {c: <span class="hljs-number">3</span>}}}) <span class="hljs-comment">//= 3</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.pathOn = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pathOn</span><span class="hljs-params">(sep, str, obj)</span> </span>{
            <span class="hljs-keyword">return</span> path(str.split(sep), obj);
        });

        <span class="hljs-comment">/**
         * Retrieve a nested path on an object seperated by periods
         *
         * @static
         * @memberOf R
         * @param {string} path The dot path to use.
         * @return {*} The data at `path`.
         * @example
         * path('a.b', {a: {b: 2}}) //= 2
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>Retrieve a nested path on an object seperated by periods
R.path(‘a.b’, {a: {b: 2}}) //= 2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.path = R.pathOn(<span class="hljs-string">'.'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <h2 id="data-analysis-and-grouping-functions">Data Analysis and Grouping Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>Functions performing SQL-like actions on lists of objects.  These do
not have any SQL-like optimizations performed on them, however.</p>

            </div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>Reasonable analog to SQL <code>select</code> statement.</p>
<pre><code><span class="hljs-keyword">var</span> abby = {name: <span class="hljs-string">'Abby'</span>, age: <span class="hljs-number">7</span>, hair: <span class="hljs-string">'blond'</span>, grade: <span class="hljs-number">2</span>},
<span class="hljs-keyword">var</span> fred = {name: <span class="hljs-string">'Fred'</span>, age: <span class="hljs-number">12</span>, hair: <span class="hljs-string">'brown'</span>, grade: <span class="hljs-number">7</span>}
<span class="hljs-keyword">var</span> kids = [abby, fred];
project([<span class="hljs-string">'name'</span>, <span class="hljs-string">'grade'</span>], kids);
<span class="hljs-comment">//= [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.project = useWith(map, R.pickAll, identity); <span class="hljs-comment">// passing `identity` gives correct arity</span>

        <span class="hljs-comment">/**
         * Determines whether the given property of an object has a specific
         * value according to strict equality (`===`).  Most likely used to
         * filter a list:
         *
         * @static
         * @memberOf R
         * @param {string|number} name The property name (or index) to use.
         * @param {*} val The value to compare the property with.
         * @return {boolean} `true` if the properties are equal, `false` otherwise.
         * @example
         *
         * var abby = {name: 'Abby', age: 7, hair: 'blond'};
         * var fred = {name: 'Fred', age: 12, hair: 'brown'};
         * var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
         * var alois = {name: 'Alois', age: 15, disposition: 'surly'};
         * var kids = [abby, fred, rusty, alois];
         * var hasBrownHair = propEq("hair", "brown");
         * filter(hasBrownHair, kids); //= [fred, rusty]
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>Determines whether the given property of an object has a specific value
Most likely used to filter a list:</p>
<pre><code><span class="hljs-keyword">var</span> abby = {name: <span class="hljs-string">'Abby'</span>, age: <span class="hljs-number">7</span>, hair: <span class="hljs-string">'blond'</span>};
<span class="hljs-keyword">var</span> fred = {name: <span class="hljs-string">'Fred'</span>, age: <span class="hljs-number">12</span>, hair: <span class="hljs-string">'brown'</span>};
<span class="hljs-keyword">var</span> rusty = {name: <span class="hljs-string">'Rusty'</span>, age: <span class="hljs-number">10</span>, hair: <span class="hljs-string">'brown'</span>};
<span class="hljs-keyword">var</span> alois = {name: <span class="hljs-string">'Alois'</span>, age: <span class="hljs-number">15</span>, disposition: <span class="hljs-string">'surly'</span>};
<span class="hljs-keyword">var</span> kids = [abby, fred, rusty, alois];
<span class="hljs-keyword">var</span> hasBrownHair = propEq(<span class="hljs-string">"hair"</span>, <span class="hljs-string">"brown"</span>);
filter(hasBrownHair, kids); <span class="hljs-comment">//= [fred, rusty]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.propEq = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">propEq</span><span class="hljs-params">(name, val, obj)</span> </span>{
            <span class="hljs-keyword">return</span> obj[name] === val;
        });

        <span class="hljs-comment">/**
         * Combines two lists into a set (i.e. no duplicates) composed of the
         * elements of each list.
         *
         * @static
         * @memberOf R
         * @param {Array} as The first list.
         * @param {Array} bs The second list.
         * @return {Array} The first and second lists concatenated, with
         * duplicates removed.
         * @example
         *
         * union([1, 2, 3], [2, 3, 4]); //= [1, 2, 3, 4]
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>Combines two lists into a set (i.e. no duplicates) composed of the
elements of each list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.union = compose(uniq, R.concat);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <p>Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is
determined according to the value returned by applying the supplied predicate to two list elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.unionWith = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unionWith</span><span class="hljs-params">(pred, list1, list2)</span> </span>{
            <span class="hljs-keyword">return</span> uniqWith(pred, concat(list1, list2));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.difference = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_difference</span><span class="hljs-params">(first, second)</span> </span>{
            <span class="hljs-keyword">return</span> uniq(reject(flip(contains)(second), first));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
Duplication is determined according to the value returned by applying the supplied predicate to two list
elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.differenceWith = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">differenceWith</span><span class="hljs-params">(pred, first, second)</span> </span>{
            <span class="hljs-keyword">return</span> uniqWith(pred)(reject(flip(R.containsWith(pred))(second), first));
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.intersection = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span><span class="hljs-params">(list1, list2)</span> </span>{
            <span class="hljs-keyword">return</span> uniq(filter(flip(contains)(list1), list2));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.
Duplication is determined according to the value returned by applying the supplied predicate to two list
elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.intersectionWith = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersectionWith</span><span class="hljs-params">(pred, list1, list2)</span> </span>{
            <span class="hljs-keyword">var</span> results = [], idx = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++idx &lt; list1.length) {
                <span class="hljs-keyword">if</span> (containsWith(pred, list1[idx], list2)) {
                    results[results.length] = list1[idx];
                }
            }
            <span class="hljs-keyword">return</span> uniqWith(pred, results);
        });

        <span class="hljs-comment">/**
         * Creates a new list whose elements each have two properties: `val` is
         * the value of the corresponding item in the list supplied, and `key`
         * is the result of applying the supplied function to that item.
         *
         * @static
         * @private
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>Creates a new list whose elements each have two properties: <code>val</code> is
the value of the corresponding item in the list supplied, and <code>key</code>
is the result of applying the supplied function to that item.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keyValue</span><span class="hljs-params">(fn, list)</span> </span>{ <span class="hljs-comment">// TODO: Should this be made public?</span>
            <span class="hljs-keyword">return</span> map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> </span>{<span class="hljs-keyword">return</span> {key: fn(item), val: item};}, list);
        }

        <span class="hljs-comment">/**
         * Sorts the list according to a key generated by the supplied function.
         *
         * @static
         * @memberOf R
         * @param {Function} fn The function mapping `list` items to keys.
         * @param {Array} list The list to sort.
         * @return {Array} A new list sorted by the keys generated by `fn`.
         * @example
         *
         * var sortByFirstItem = sortBy(nth(0));
         * var sortByNameCaseInsensitive = sortBy(compose(toLowerCase, prop("name")));
         * var pairs = [[-1, 1], [-2, 2], [-3, 3]];
         * sortByFirstItem(pairs); //= [[-3, 3], [-2, 2], [-1, 1]]
         * var alice = {
         *      name: "ALICE",
         *      age: 101
         * };
         * var bob = {
         *      name: "Bob",
         *      age: -10
         * };
         * var clara = {
         *      name: "clara",
         *      age: 314.159
         * };
         * var people = [clara, bob, alice];
         * sortByNameCaseInsensitive(people); //= [alice, bob, clara]
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>Sorts the list according to a key generated by the supplied function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.sortBy = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortyBy</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-comment">/*
              return sort(comparator(function(a, b) {return fn(a) &lt; fn(b);}), list); // clean, but too time-inefficient
              return pluck("val", sort(comparator(function(a, b) {return a.key &lt; b.key;}), keyValue(fn, list))); // nice, but no need to clone result of keyValue call, so...
            */</span>
            <span class="hljs-keyword">return</span> pluck(<span class="hljs-string">"val"</span>, keyValue(fn, list).sort(comparator(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{<span class="hljs-keyword">return</span> a.key &lt; b.key;})));
        });

        <span class="hljs-comment">/**
         * Counts the elements of a list according to how many match each value
         * of a key generated by the supplied function. Returns an object
         * mapping the keys produced by `fn` to the number of occurrences in
         * the list. Note that all keys are coerced to strings because of how
         * JavaScript objects work.
         *
         * @static
         * @memberOf R
         * @param {Function} fn The function used to map values to keys.
         * @param {Array} list The list to count elements from.
         * @return {Object} An object mapping keys to number of occurrences in the list.
         * @example
         *
         * var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
         * var letters = split("", "abcABCaaaBBc");
         * countBy(Math.floor)(numbers);    //= {"1": 3, "2": 2, "3": 1}
         * countBy(toLowerCase)(letters);   //= {"a": 5, "b": 4, "c": 3}
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>Counts the elements of a list according to how many match each value
of a key generated by the supplied function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.countBy = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countBy</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(counts, obj)</span> </span>{
                counts[obj.key] = (counts[obj.key] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">return</span> counts;
            }, {}, keyValue(fn, list));
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>All the functional goodness, wrapped in a nice little package, just for you!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> R;
    }());
}));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
  <script src="http://cdn.jsdelivr.net/ramda/latest/ramda.min.js"></script>
</body>
</html>
